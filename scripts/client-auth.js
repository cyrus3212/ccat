!function (modules) { function __webpack_require__(moduleId) { if (installedModules[moduleId]) return installedModules[moduleId].exports; var module = installedModules[moduleId] = { exports: {}, id: moduleId, loaded: !1 }; return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), module.loaded = !0, module.exports } var installedModules = {}; return __webpack_require__.m = modules, __webpack_require__.c = installedModules, __webpack_require__.p = "/dist/", __webpack_require__(0) }([function (module, exports, __webpack_require__) { __webpack_require__(1), __webpack_require__(5), module.exports = __webpack_require__(6) }, function (module, exports, __webpack_require__) { self.Promise || (self.Promise = __webpack_require__(2)) }, function (module, exports, __webpack_require__) { (function (setImmediate) { !function (root) { function noop() { } function bind(fn, thisArg) { return function () { fn.apply(thisArg, arguments) } } function Promise(fn) { if ("object" != typeof this) throw new TypeError("Promises must be constructed via new"); if ("function" != typeof fn) throw new TypeError("not a function"); this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], doResolve(fn, this) } function handle(self, deferred) { for (; 3 === self._state;)self = self._value; return 0 === self._state ? void self._deferreds.push(deferred) : (self._handled = !0, void Promise._immediateFn(function () { var cb = 1 === self._state ? deferred.onFulfilled : deferred.onRejected; if (null === cb) return void (1 === self._state ? resolve : reject)(deferred.promise, self._value); var ret; try { ret = cb(self._value) } catch (e) { return void reject(deferred.promise, e) } resolve(deferred.promise, ret) })) } function resolve(self, newValue) { try { if (newValue === self) throw new TypeError("A promise cannot be resolved with itself."); if (newValue && ("object" == typeof newValue || "function" == typeof newValue)) { var then = newValue.then; if (newValue instanceof Promise) return self._state = 3, self._value = newValue, void finale(self); if ("function" == typeof then) return void doResolve(bind(then, newValue), self) } self._state = 1, self._value = newValue, finale(self) } catch (e) { reject(self, e) } } function reject(self, newValue) { self._state = 2, self._value = newValue, finale(self) } function finale(self) { 2 === self._state && 0 === self._deferreds.length && Promise._immediateFn(function () { self._handled || Promise._unhandledRejectionFn(self._value) }); for (var i = 0, len = self._deferreds.length; i < len; i++)handle(self, self._deferreds[i]); self._deferreds = null } function Handler(onFulfilled, onRejected, promise) { this.onFulfilled = "function" == typeof onFulfilled ? onFulfilled : null, this.onRejected = "function" == typeof onRejected ? onRejected : null, this.promise = promise } function doResolve(fn, self) { var done = !1; try { fn(function (value) { done || (done = !0, resolve(self, value)) }, function (reason) { done || (done = !0, reject(self, reason)) }) } catch (ex) { if (done) return; done = !0, reject(self, ex) } } var setTimeoutFunc = setTimeout; Promise.prototype["catch"] = function (onRejected) { return this.then(null, onRejected) }, Promise.prototype.then = function (onFulfilled, onRejected) { var prom = new this.constructor(noop); return handle(this, new Handler(onFulfilled, onRejected, prom)), prom }, Promise.all = function (arr) { var args = Array.prototype.slice.call(arr); return new Promise(function (resolve, reject) { function res(i, val) { try { if (val && ("object" == typeof val || "function" == typeof val)) { var then = val.then; if ("function" == typeof then) return void then.call(val, function (val) { res(i, val) }, reject) } args[i] = val, 0 === --remaining && resolve(args) } catch (ex) { reject(ex) } } if (0 === args.length) return resolve([]); for (var remaining = args.length, i = 0; i < args.length; i++)res(i, args[i]) }) }, Promise.resolve = function (value) { return value && "object" == typeof value && value.constructor === Promise ? value : new Promise(function (resolve) { resolve(value) }) }, Promise.reject = function (value) { return new Promise(function (resolve, reject) { reject(value) }) }, Promise.race = function (values) { return new Promise(function (resolve, reject) { for (var i = 0, len = values.length; i < len; i++)values[i].then(resolve, reject) }) }, Promise._immediateFn = "function" == typeof setImmediate && function (fn) { setImmediate(fn) } || function (fn) { setTimeoutFunc(fn, 0) }, Promise._unhandledRejectionFn = function (err) { "undefined" != typeof console && console && console.warn("Possible Unhandled Promise Rejection:", err) }, Promise._setImmediateFn = function (fn) { Promise._immediateFn = fn }, Promise._setUnhandledRejectionFn = function (fn) { Promise._unhandledRejectionFn = fn }, "undefined" != typeof module && module.exports ? module.exports = Promise : root.Promise || (root.Promise = Promise) }(this) }).call(exports, __webpack_require__(3).setImmediate) }, function (module, exports, __webpack_require__) { (function (setImmediate, clearImmediate) { function Timeout(id, clearFn) { this._id = id, this._clearFn = clearFn } var nextTick = __webpack_require__(4).nextTick, apply = Function.prototype.apply, slice = Array.prototype.slice, immediateIds = {}, nextImmediateId = 0; exports.setTimeout = function () { return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout) }, exports.setInterval = function () { return new Timeout(apply.call(setInterval, window, arguments), clearInterval) }, exports.clearTimeout = exports.clearInterval = function (timeout) { timeout.close() }, Timeout.prototype.unref = Timeout.prototype.ref = function () { }, Timeout.prototype.close = function () { this._clearFn.call(window, this._id) }, exports.enroll = function (item, msecs) { clearTimeout(item._idleTimeoutId), item._idleTimeout = msecs }, exports.unenroll = function (item) { clearTimeout(item._idleTimeoutId), item._idleTimeout = -1 }, exports._unrefActive = exports.active = function (item) { clearTimeout(item._idleTimeoutId); var msecs = item._idleTimeout; msecs >= 0 && (item._idleTimeoutId = setTimeout(function () { item._onTimeout && item._onTimeout() }, msecs)) }, exports.setImmediate = "function" == typeof setImmediate ? setImmediate : function (fn) { var id = nextImmediateId++, args = !(arguments.length < 2) && slice.call(arguments, 1); return immediateIds[id] = !0, nextTick(function () { immediateIds[id] && (args ? fn.apply(null, args) : fn.call(null), exports.clearImmediate(id)) }), id }, exports.clearImmediate = "function" == typeof clearImmediate ? clearImmediate : function (id) { delete immediateIds[id] } }).call(exports, __webpack_require__(3).setImmediate, __webpack_require__(3).clearImmediate) }, function (module, exports) { function defaultSetTimout() { throw new Error("setTimeout has not been defined") } function defaultClearTimeout() { throw new Error("clearTimeout has not been defined") } function runTimeout(fun) { if (cachedSetTimeout === setTimeout) return setTimeout(fun, 0); if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) return cachedSetTimeout = setTimeout, setTimeout(fun, 0); try { return cachedSetTimeout(fun, 0) } catch (e) { try { return cachedSetTimeout.call(null, fun, 0) } catch (e) { return cachedSetTimeout.call(this, fun, 0) } } } function runClearTimeout(marker) { if (cachedClearTimeout === clearTimeout) return clearTimeout(marker); if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) return cachedClearTimeout = clearTimeout, clearTimeout(marker); try { return cachedClearTimeout(marker) } catch (e) { try { return cachedClearTimeout.call(null, marker) } catch (e) { return cachedClearTimeout.call(this, marker) } } } function cleanUpNextTick() { draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue()) } function drainQueue() { if (!draining) { var timeout = runTimeout(cleanUpNextTick); draining = !0; for (var len = queue.length; len;) { for (currentQueue = queue, queue = []; ++queueIndex < len;)currentQueue && currentQueue[queueIndex].run(); queueIndex = -1, len = queue.length } currentQueue = null, draining = !1, runClearTimeout(timeout) } } function Item(fun, array) { this.fun = fun, this.array = array } function noop() { } var cachedSetTimeout, cachedClearTimeout, process = module.exports = {}; !function () { try { cachedSetTimeout = "function" == typeof setTimeout ? setTimeout : defaultSetTimout } catch (e) { cachedSetTimeout = defaultSetTimout } try { cachedClearTimeout = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout } catch (e) { cachedClearTimeout = defaultClearTimeout } }(); var currentQueue, queue = [], draining = !1, queueIndex = -1; process.nextTick = function (fun) { var args = new Array(arguments.length - 1); if (arguments.length > 1) for (var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i]; queue.push(new Item(fun, args)), 1 !== queue.length || draining || runTimeout(drainQueue) }, Item.prototype.run = function () { this.fun.apply(null, this.array) }, process.title = "browser", process.browser = !0, process.env = {}, process.argv = [], process.version = "", process.versions = {}, process.on = noop, process.addListener = noop, process.once = noop, process.off = noop, process.removeListener = noop, process.removeAllListeners = noop, process.emit = noop, process.prependListener = noop, process.prependOnceListener = noop, process.listeners = function (name) { return [] }, process.binding = function (name) { throw new Error("process.binding is not supported") }, process.cwd = function () { return "/" }, process.chdir = function (dir) { throw new Error("process.chdir is not supported") }, process.umask = function () { return 0 } }, function (module, exports) { !function (self) { "use strict"; function normalizeName(name) { if ("string" != typeof name && (name = String(name)), /[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) throw new TypeError("Invalid character in header field name"); return name.toLowerCase() } function normalizeValue(value) { return "string" != typeof value && (value = String(value)), value } function iteratorFor(items) { var iterator = { next: function () { var value = items.shift(); return { done: void 0 === value, value: value } } }; return support.iterable && (iterator[Symbol.iterator] = function () { return iterator }), iterator } function Headers(headers) { this.map = {}, headers instanceof Headers ? headers.forEach(function (value, name) { this.append(name, value) }, this) : headers && Object.getOwnPropertyNames(headers).forEach(function (name) { this.append(name, headers[name]) }, this) } function consumed(body) { return body.bodyUsed ? Promise.reject(new TypeError("Already read")) : void (body.bodyUsed = !0) } function fileReaderReady(reader) { return new Promise(function (resolve, reject) { reader.onload = function () { resolve(reader.result) }, reader.onerror = function () { reject(reader.error) } }) } function readBlobAsArrayBuffer(blob) { var reader = new FileReader; return reader.readAsArrayBuffer(blob), fileReaderReady(reader) } function readBlobAsText(blob) { var reader = new FileReader; return reader.readAsText(blob), fileReaderReady(reader) } function Body() { return this.bodyUsed = !1, this._initBody = function (body) { if (this._bodyInit = body, "string" == typeof body) this._bodyText = body; else if (support.blob && Blob.prototype.isPrototypeOf(body)) this._bodyBlob = body; else if (support.formData && FormData.prototype.isPrototypeOf(body)) this._bodyFormData = body; else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) this._bodyText = body.toString(); else if (body) { if (!support.arrayBuffer || !ArrayBuffer.prototype.isPrototypeOf(body)) throw new Error("unsupported BodyInit type") } else this._bodyText = ""; this.headers.get("content-type") || ("string" == typeof body ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : support.searchParams && URLSearchParams.prototype.isPrototypeOf(body) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8")) }, support.blob ? (this.blob = function () { var rejected = consumed(this); if (rejected) return rejected; if (this._bodyBlob) return Promise.resolve(this._bodyBlob); if (this._bodyFormData) throw new Error("could not read FormData body as blob"); return Promise.resolve(new Blob([this._bodyText])) }, this.arrayBuffer = function () { return this.blob().then(readBlobAsArrayBuffer) }, this.text = function () { var rejected = consumed(this); if (rejected) return rejected; if (this._bodyBlob) return readBlobAsText(this._bodyBlob); if (this._bodyFormData) throw new Error("could not read FormData body as text"); return Promise.resolve(this._bodyText) }) : this.text = function () { var rejected = consumed(this); return rejected ? rejected : Promise.resolve(this._bodyText) }, support.formData && (this.formData = function () { return this.text().then(decode) }), this.json = function () { return this.text().then(JSON.parse) }, this } function normalizeMethod(method) { var upcased = method.toUpperCase(); return methods.indexOf(upcased) > -1 ? upcased : method } function Request(input, options) { options = options || {}; var body = options.body; if (Request.prototype.isPrototypeOf(input)) { if (input.bodyUsed) throw new TypeError("Already read"); this.url = input.url, this.credentials = input.credentials, options.headers || (this.headers = new Headers(input.headers)), this.method = input.method, this.mode = input.mode, body || (body = input._bodyInit, input.bodyUsed = !0) } else this.url = input; if (this.credentials = options.credentials || this.credentials || "omit", !options.headers && this.headers || (this.headers = new Headers(options.headers)), this.method = normalizeMethod(options.method || this.method || "GET"), this.mode = options.mode || this.mode || null, this.referrer = null, ("GET" === this.method || "HEAD" === this.method) && body) throw new TypeError("Body not allowed for GET or HEAD requests"); this._initBody(body) } function decode(body) { var form = new FormData; return body.trim().split("&").forEach(function (bytes) { if (bytes) { var split = bytes.split("="), name = split.shift().replace(/\+/g, " "), value = split.join("=").replace(/\+/g, " "); form.append(decodeURIComponent(name), decodeURIComponent(value)) } }), form } function headers(xhr) { var head = new Headers, pairs = (xhr.getAllResponseHeaders() || "").trim().split("\n"); return pairs.forEach(function (header) { var split = header.trim().split(":"), key = split.shift().trim(), value = split.join(":").trim(); head.append(key, value) }), head } function Response(bodyInit, options) { options || (options = {}), this.type = "default", this.status = options.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = options.statusText, this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers), this.url = options.url || "", this._initBody(bodyInit) } if (!self.fetch) { var support = { searchParams: "URLSearchParams" in self, iterable: "Symbol" in self && "iterator" in Symbol, blob: "FileReader" in self && "Blob" in self && function () { try { return new Blob, !0 } catch (e) { return !1 } }(), formData: "FormData" in self, arrayBuffer: "ArrayBuffer" in self }; Headers.prototype.append = function (name, value) { name = normalizeName(name), value = normalizeValue(value); var list = this.map[name]; list || (list = [], this.map[name] = list), list.push(value) }, Headers.prototype["delete"] = function (name) { delete this.map[normalizeName(name)] }, Headers.prototype.get = function (name) { var values = this.map[normalizeName(name)]; return values ? values[0] : null }, Headers.prototype.getAll = function (name) { return this.map[normalizeName(name)] || [] }, Headers.prototype.has = function (name) { return this.map.hasOwnProperty(normalizeName(name)) }, Headers.prototype.set = function (name, value) { this.map[normalizeName(name)] = [normalizeValue(value)] }, Headers.prototype.forEach = function (callback, thisArg) { Object.getOwnPropertyNames(this.map).forEach(function (name) { this.map[name].forEach(function (value) { callback.call(thisArg, value, name, this) }, this) }, this) }, Headers.prototype.keys = function () { var items = []; return this.forEach(function (value, name) { items.push(name) }), iteratorFor(items) }, Headers.prototype.values = function () { var items = []; return this.forEach(function (value) { items.push(value) }), iteratorFor(items) }, Headers.prototype.entries = function () { var items = []; return this.forEach(function (value, name) { items.push([name, value]) }), iteratorFor(items) }, support.iterable && (Headers.prototype[Symbol.iterator] = Headers.prototype.entries); var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"]; Request.prototype.clone = function () { return new Request(this) }, Body.call(Request.prototype), Body.call(Response.prototype), Response.prototype.clone = function () { return new Response(this._bodyInit, { status: this.status, statusText: this.statusText, headers: new Headers(this.headers), url: this.url }) }, Response.error = function () { var response = new Response(null, { status: 0, statusText: "" }); return response.type = "error", response }; var redirectStatuses = [301, 302, 303, 307, 308]; Response.redirect = function (url, status) { if (redirectStatuses.indexOf(status) === -1) throw new RangeError("Invalid status code"); return new Response(null, { status: status, headers: { location: url } }) }, self.Headers = Headers, self.Request = Request, self.Response = Response, self.fetch = function (input, init) { return new Promise(function (resolve, reject) { function responseURL() { return "responseURL" in xhr ? xhr.responseURL : /^X-Request-URL:/m.test(xhr.getAllResponseHeaders()) ? xhr.getResponseHeader("X-Request-URL") : void 0 } var request; request = Request.prototype.isPrototypeOf(input) && !init ? input : new Request(input, init); var xhr = new XMLHttpRequest; xhr.onload = function () { var options = { status: xhr.status, statusText: xhr.statusText, headers: headers(xhr), url: responseURL() }, body = "response" in xhr ? xhr.response : xhr.responseText; resolve(new Response(body, options)) }, xhr.onerror = function () { reject(new TypeError("Network request failed")) }, xhr.ontimeout = function () { reject(new TypeError("Network request failed")) }, xhr.open(request.method, request.url, !0), "include" === request.credentials && (xhr.withCredentials = !0), "responseType" in xhr && support.blob && (xhr.responseType = "blob"), request.headers.forEach(function (value, name) { xhr.setRequestHeader(name, value) }), xhr.send("undefined" == typeof request._bodyInit ? null : request._bodyInit) }) }, self.fetch.polyfill = !0 } }("undefined" != typeof self ? self : this) }, function (module, exports, __webpack_require__) { var auth0 = __webpack_require__(7), getAuthClient = __webpack_require__(66); window.coxautoinc || (window.coxautoinc = {}), window.coxautoinc.auth || (window.coxautoinc.auth = {}), window.coxautoinc.auth.AuthClient = getAuthClient(auth0, window) }, function (module, exports, __webpack_require__) { var Authentication = __webpack_require__(8), Management = __webpack_require__(35), WebAuth = __webpack_require__(36), version = __webpack_require__(20); module.exports = { Authentication: Authentication, Management: Management, WebAuth: WebAuth, version: version.raw } }, function (module, exports, __webpack_require__) { function Authentication(options) { assert.check(options, { type: "object", message: "options parameter is not valid" }, { domain: { type: "string", message: "domain option is required" }, clientID: { type: "string", message: "clientID option is required" }, responseType: { optional: !0, type: "string", message: "responseType is not valid" }, responseMode: { optional: !0, type: "string", message: "responseMode is not valid" }, redirectUri: { optional: !0, type: "string", message: "redirectUri is not valid" }, scope: { optional: !0, type: "string", message: "scope is not valid" }, audience: { optional: !0, type: "string", message: "audience is not valid" }, _disableDeprecationWarnings: { optional: !0, type: "boolean", message: "_disableDeprecationWarnings option is not valid" }, _sendTelemetry: { optional: !0, type: "boolean", message: "_sendTelemetry option is not valid" }, _telemetryInfo: { optional: !0, type: "object", message: "_telemetryInfo option is not valid" } }), this.baseOptions = options, this.baseOptions._sendTelemetry = this.baseOptions._sendTelemetry !== !1 || this.baseOptions._sendTelemetry, this.baseOptions.rootUrl = "https://" + this.baseOptions.domain, this.request = new RequestBuilder(this.baseOptions), this.passwordless = new PasswordlessAuthentication(this.request, this.baseOptions), this.dbConnection = new DBConnection(this.request, this.baseOptions), this.warn = new Warn({ disableWarnings: !!options._disableDeprecationWarnings }) } var urljoin = __webpack_require__(9), RequestBuilder = __webpack_require__(10), qs = __webpack_require__(21), objectHelper = __webpack_require__(26), assert = __webpack_require__(27), responseHandler = __webpack_require__(29), parametersWhitelist = __webpack_require__(31), Warn = __webpack_require__(32), PasswordlessAuthentication = __webpack_require__(33), DBConnection = __webpack_require__(34); Authentication.prototype.buildAuthorizeUrl = function (options) { var params, qString; return assert.check(options, { type: "object", message: "options parameter is not valid" }), params = objectHelper.merge(this.baseOptions, ["clientID", "responseType", "responseMode", "redirectUri", "scope", "audience"])["with"](options), assert.check(params, { type: "object", message: "options parameter is not valid" }, { clientID: { type: "string", message: "clientID option is required" }, redirectUri: { optional: !0, type: "string", message: "redirectUri option is required" }, responseType: { type: "string", message: "responseType option is required" }, nonce: { type: "string", message: "nonce option is required", condition: function (o) { return o.responseType.indexOf("code") === -1 && o.responseType.indexOf("id_token") !== -1 } }, scope: { optional: !0, type: "string", message: "scope option is required" }, audience: { optional: !0, type: "string", message: "audience option is required" } }), this.baseOptions._sendTelemetry && (params.auth0Client = this.request.getTelemetryData()), params.connection_scope && assert.isArray(params.connection_scope) && (params.connection_scope = params.connection_scope.join(",")), params = objectHelper.toSnakeCase(params, ["auth0Client"]), params = parametersWhitelist.oauthAuthorizeParams(this.warn, params), qString = qs.stringify(params), urljoin(this.baseOptions.rootUrl, "authorize", "?" + qString) }, Authentication.prototype.buildLogoutUrl = function (options) { var params, qString; return assert.check(options, { optional: !0, type: "object", message: "options parameter is not valid" }), params = objectHelper.merge(this.baseOptions, ["clientID"])["with"](options || {}), this.baseOptions._sendTelemetry && (params.auth0Client = this.request.getTelemetryData()), params = objectHelper.toSnakeCase(params, ["auth0Client", "returnTo"]), qString = qs.stringify(params), urljoin(this.baseOptions.rootUrl, "v2", "logout", "?" + qString) }, Authentication.prototype.loginWithDefaultDirectory = function (options, cb) { return assert.check(options, { type: "object", message: "options parameter is not valid" }, { username: { type: "string", message: "username option is required" }, password: { type: "string", message: "password option is required" }, scope: { optional: !0, type: "string", message: "scope option is required" }, audience: { optional: !0, type: "string", message: "audience option is required" } }), options.grantType = "password", this.oauthToken(options, cb) }, Authentication.prototype.login = function (options, cb) { return assert.check(options, { type: "object", message: "options parameter is not valid" }, { username: { type: "string", message: "username option is required" }, password: { type: "string", message: "password option is required" }, realm: { type: "string", message: "realm option is required" }, scope: { optional: !0, type: "string", message: "scope option is required" }, audience: { optional: !0, type: "string", message: "audience option is required" } }), options.grantType = "http://auth0.com/oauth/grant-type/password-realm", this.oauthToken(options, cb) }, Authentication.prototype.oauthToken = function (options, cb) { var url, body; return assert.check(options, { type: "object", message: "options parameter is not valid" }), assert.check(cb, { type: "function", message: "cb parameter is not valid" }), url = urljoin(this.baseOptions.rootUrl, "oauth", "token"), body = objectHelper.merge(this.baseOptions, ["clientID", "scope", "audience"])["with"](options), assert.check(body, { type: "object", message: "options parameter is not valid" }, { clientID: { type: "string", message: "clientID option is required" }, grantType: { type: "string", message: "grantType option is required" }, scope: { optional: !0, type: "string", message: "scope option is required" }, audience: { optional: !0, type: "string", message: "audience option is required" } }), body = objectHelper.toSnakeCase(body, ["auth0Client"]), body = parametersWhitelist.oauthTokenParams(this.warn, body), body.grant_type = body.grant_type, this.request.post(url).send(body).end(responseHandler(cb)) }, Authentication.prototype.loginWithResourceOwner = function (options, cb) { var url, body; return assert.check(options, { type: "object", message: "options parameter is not valid" }, { username: { type: "string", message: "username option is required" }, password: { type: "string", message: "password option is required" }, connection: { type: "string", message: "connection option is required" }, scope: { optional: !0, type: "string", message: "scope option is required" } }), assert.check(cb, { type: "function", message: "cb parameter is not valid" }), url = urljoin(this.baseOptions.rootUrl, "oauth", "ro"), body = objectHelper.merge(this.baseOptions, ["clientID", "scope"])["with"](options, ["username", "password", "scope", "connection", "device"]), body = objectHelper.toSnakeCase(body, ["auth0Client"]), body.grant_type = body.grant_type || "password", this.request.post(url).send(body).end(responseHandler(cb)) }, Authentication.prototype.getSSOData = function (withActiveDirectories, cb) { var url, params = ""; return "function" == typeof withActiveDirectories && (cb = withActiveDirectories, withActiveDirectories = !1), assert.check(withActiveDirectories, { type: "boolean", message: "withActiveDirectories parameter is not valid" }), assert.check(cb, { type: "function", message: "cb parameter is not valid" }), withActiveDirectories && (params = "?" + qs.stringify({ ldaps: 1, client_id: this.baseOptions.clientID })), url = urljoin(this.baseOptions.rootUrl, "user", "ssodata", params), this.request.get(url, { noHeaders: !0 }).withCredentials().end(responseHandler(cb)) }, Authentication.prototype.userInfo = function (accessToken, cb) { var url; return assert.check(accessToken, { type: "string", message: "accessToken parameter is not valid" }), assert.check(cb, { type: "function", message: "cb parameter is not valid" }), url = urljoin(this.baseOptions.rootUrl, "userinfo"), this.request.get(url).set("Authorization", "Bearer " + accessToken).end(responseHandler(cb, { ignoreCasing: !0 })) }, Authentication.prototype.delegation = function (options, cb) { var url, body; return assert.check(options, { type: "object", message: "options parameter is not valid" }, { grant_type: { type: "string", message: "grant_type option is required" } }), assert.check(cb, { type: "function", message: "cb parameter is not valid" }), url = urljoin(this.baseOptions.rootUrl, "delegation"), body = objectHelper.merge(this.baseOptions, ["clientID"])["with"](options), body = objectHelper.toSnakeCase(body, ["auth0Client"]), this.request.post(url).send(body).end(responseHandler(cb)) }, Authentication.prototype.getUserCountry = function (cb) { var url; return assert.check(cb, { type: "function", message: "cb parameter is not valid" }), url = urljoin(this.baseOptions.rootUrl, "user", "geoloc", "country"), this.request.get(url).end(responseHandler(cb)) }, module.exports = Authentication }, function (module, exports, __webpack_require__) { var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__; !function (name, context, definition) { "undefined" != typeof module && module.exports ? module.exports = definition() : (__WEBPACK_AMD_DEFINE_FACTORY__ = definition, __WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof __WEBPACK_AMD_DEFINE_FACTORY__ ? __WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module) : __WEBPACK_AMD_DEFINE_FACTORY__, !(void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))) }("urljoin", this, function () { function normalize(str, options) { return str = str.replace(/:\//g, "://"), str = str.replace(/([^:\s])\/+/g, "$1/"), str = str.replace(/\/(\?|&|#[^!])/g, "$1"), str = str.replace(/(\?.+)\?/g, "$1&") } return function () { var input = arguments, options = {}; "object" == typeof arguments[0] && (input = arguments[0], options = arguments[1] || {}); var joined = [].slice.call(input, 0).join("/"); return normalize(joined, options) } }) }, function (module, exports, __webpack_require__) { function RequestWrapper(req) { this.request = req, this.method = req.method, this.url = req.url, this.body = req._data, this.headers = req._header } function RequestObj(req) { this.request = req } function RequestBuilder(options) { this._sendTelemetry = options._sendTelemetry !== !1 || options._sendTelemetry, this._telemetryInfo = options._telemetryInfo || null, this._timesToRetryFailedRequests = options._timesToRetryFailedRequests, this.headers = options.headers || {} } var request = __webpack_require__(11), base64Url = __webpack_require__(18), version = __webpack_require__(20); RequestWrapper.prototype.abort = function () { this.request.abort() }, RequestWrapper.prototype.getMethod = function () { return this.method }, RequestWrapper.prototype.getBody = function () { return this.body }, RequestWrapper.prototype.getUrl = function () { return this.url }, RequestWrapper.prototype.getHeaders = function () { return this.headers }, RequestObj.prototype.set = function (key, value) { return this.request = this.request.set(key, value), this }, RequestObj.prototype.send = function (body) { return this.request = this.request.send(body), this }, RequestObj.prototype.withCredentials = function () { return this.request = this.request.withCredentials(), this }, RequestObj.prototype.end = function (cb) { return this.request = this.request.end(cb), new RequestWrapper(this.request) }, RequestBuilder.prototype.setCommonConfiguration = function (ongoingRequest, options) { if (options = options || {}, options.noHeaders) return ongoingRequest; var headers = this.headers; ongoingRequest = ongoingRequest.set("Content-Type", "application/json"); for (var keys = Object.keys(this.headers), a = 0; a < keys.length; a++)ongoingRequest = ongoingRequest.set(keys[a], headers[keys[a]]); return this._sendTelemetry && (ongoingRequest = ongoingRequest.set("Auth0-Client", this.getTelemetryData())), this._timesToRetryFailedRequests > 0 && (ongoingRequest = ongoingRequest.retry(this._timesToRetryFailedRequests)), ongoingRequest }, RequestBuilder.prototype.getTelemetryData = function () { var clientInfo = this._telemetryInfo || { name: "auth0.js", version: version.raw }, jsonClientInfo = JSON.stringify(clientInfo); return base64Url.encode(jsonClientInfo) }, RequestBuilder.prototype.get = function (url, options) { return new RequestObj(this.setCommonConfiguration(request.get(url), options)) }, RequestBuilder.prototype.post = function (url, options) { return new RequestObj(this.setCommonConfiguration(request.post(url), options)) }, RequestBuilder.prototype.patch = function (url, options) { return new RequestObj(this.setCommonConfiguration(request.patch(url), options)) }, module.exports = RequestBuilder }, function (module, exports, __webpack_require__) {
  function noop() { } function serialize(obj) { if (!isObject(obj)) return obj; var pairs = []; for (var key in obj) pushEncodedKeyValuePair(pairs, key, obj[key]); return pairs.join("&") } function pushEncodedKeyValuePair(pairs, key, val) { if (null != val) if (Array.isArray(val)) val.forEach(function (v) { pushEncodedKeyValuePair(pairs, key, v) }); else if (isObject(val)) for (var subkey in val) pushEncodedKeyValuePair(pairs, key + "[" + subkey + "]", val[subkey]); else pairs.push(encodeURIComponent(key) + "=" + encodeURIComponent(val)); else null === val && pairs.push(encodeURIComponent(key)) } function parseString(str) { for (var pair, pos, obj = {}, pairs = str.split("&"), i = 0, len = pairs.length; i < len; ++i)pair = pairs[i], pos = pair.indexOf("="), pos == -1 ? obj[decodeURIComponent(pair)] = "" : obj[decodeURIComponent(pair.slice(0, pos))] = decodeURIComponent(pair.slice(pos + 1)); return obj } function parseHeader(str) { for (var index, line, field, val, lines = str.split(/\r?\n/), fields = {}, i = 0, len = lines.length; i < len; ++i)line = lines[i], index = line.indexOf(":"), index !== -1 && (field = line.slice(0, index).toLowerCase(), val = trim(line.slice(index + 1)), fields[field] = val); return fields } function isJSON(mime) { return /[\/+]json($|[^-\w])/.test(mime) } function Response(req) { this.req = req, this.xhr = this.req.xhr, this.text = "HEAD" != this.req.method && ("" === this.xhr.responseType || "text" === this.xhr.responseType) || "undefined" == typeof this.xhr.responseType ? this.xhr.responseText : null, this.statusText = this.req.xhr.statusText; var status = this.xhr.status; 1223 === status && (status = 204), this._setStatusProperties(status), this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders()), this.header["content-type"] = this.xhr.getResponseHeader("content-type"), this._setHeaderProperties(this.header), null === this.text && req._responseType ? this.body = this.xhr.response : this.body = "HEAD" != this.req.method ? this._parseBody(this.text ? this.text : this.xhr.response) : null } function Request(method, url) {
    var self = this; this._query = this._query || [], this.method = method, this.url = url, this.header = {}, this._header = {}, this.on("end", function () {
      var err = null, res = null; try { res = new Response(self) } catch (e) { return err = new Error("Parser is unable to parse the response"), err.parse = !0, err.original = e, self.xhr ? (err.rawResponse = "undefined" == typeof self.xhr.responseType ? self.xhr.responseText : self.xhr.response, err.status = self.xhr.status ? self.xhr.status : null, err.statusCode = err.status) : (err.rawResponse = null, err.status = null), self.callback(err) } self.emit("response", res); var new_err; try { self._isResponseOK(res) || (new_err = new Error(res.statusText || "Unsuccessful HTTP response")) } catch (custom_err) {
        new_err = custom_err
      } new_err ? (new_err.original = err, new_err.response = res, new_err.status = res.status, self.callback(new_err, res)) : self.callback(null, res)
    })
  } function del(url, data, fn) { var req = request("DELETE", url); return "function" == typeof data && (fn = data, data = null), data && req.send(data), fn && req.end(fn), req } var root; "undefined" != typeof window ? root = window : "undefined" != typeof self ? root = self : (console.warn("Using browser-only version of superagent in non-browser environment"), root = this); var Emitter = __webpack_require__(12), RequestBase = __webpack_require__(13), isObject = __webpack_require__(14), ResponseBase = __webpack_require__(15), Agent = __webpack_require__(17), request = exports = module.exports = function (method, url) { return "function" == typeof url ? new exports.Request("GET", method).end(url) : 1 == arguments.length ? new exports.Request("GET", method) : new exports.Request(method, url) }; exports.Request = Request, request.getXHR = function () { if (!(!root.XMLHttpRequest || root.location && "file:" == root.location.protocol && root.ActiveXObject)) return new XMLHttpRequest; try { return new ActiveXObject("Microsoft.XMLHTTP") } catch (e) { } try { return new ActiveXObject("Msxml2.XMLHTTP.6.0") } catch (e) { } try { return new ActiveXObject("Msxml2.XMLHTTP.3.0") } catch (e) { } try { return new ActiveXObject("Msxml2.XMLHTTP") } catch (e) { } throw Error("Browser-only version of superagent could not find XHR") }; var trim = "".trim ? function (s) { return s.trim() } : function (s) { return s.replace(/(^\s*|\s*$)/g, "") }; request.serializeObject = serialize, request.parseString = parseString, request.types = { html: "text/html", json: "application/json", xml: "text/xml", urlencoded: "application/x-www-form-urlencoded", form: "application/x-www-form-urlencoded", "form-data": "application/x-www-form-urlencoded" }, request.serialize = { "application/x-www-form-urlencoded": serialize, "application/json": JSON.stringify }, request.parse = { "application/x-www-form-urlencoded": parseString, "application/json": JSON.parse }, ResponseBase(Response.prototype), Response.prototype._parseBody = function (str) { var parse = request.parse[this.type]; return this.req._parser ? this.req._parser(this, str) : (!parse && isJSON(this.type) && (parse = request.parse["application/json"]), parse && str && (str.length || str instanceof Object) ? parse(str) : null) }, Response.prototype.toError = function () { var req = this.req, method = req.method, url = req.url, msg = "cannot " + method + " " + url + " (" + this.status + ")", err = new Error(msg); return err.status = this.status, err.method = method, err.url = url, err }, request.Response = Response, Emitter(Request.prototype), RequestBase(Request.prototype), Request.prototype.type = function (type) { return this.set("Content-Type", request.types[type] || type), this }, Request.prototype.accept = function (type) { return this.set("Accept", request.types[type] || type), this }, Request.prototype.auth = function (user, pass, options) { 1 === arguments.length && (pass = ""), "object" == typeof pass && null !== pass && (options = pass, pass = ""), options || (options = { type: "function" == typeof btoa ? "basic" : "auto" }); var encoder = function (string) { if ("function" == typeof btoa) return btoa(string); throw new Error("Cannot use basic auth, btoa is not a function") }; return this._auth(user, pass, options, encoder) }, Request.prototype.query = function (val) { return "string" != typeof val && (val = serialize(val)), val && this._query.push(val), this }, Request.prototype.attach = function (field, file, options) { if (file) { if (this._data) throw Error("superagent can't mix .send() and .attach()"); this._getFormData().append(field, file, options || file.name) } return this }, Request.prototype._getFormData = function () { return this._formData || (this._formData = new root.FormData), this._formData }, Request.prototype.callback = function (err, res) { if (this._shouldRetry(err, res)) return this._retry(); var fn = this._callback; this.clearTimeout(), err && (this._maxRetries && (err.retries = this._retries - 1), this.emit("error", err)), fn(err, res) }, Request.prototype.crossDomainError = function () { var err = new Error("Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc."); err.crossDomain = !0, err.status = this.status, err.method = this.method, err.url = this.url, this.callback(err) }, Request.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function () { return console.warn("This is not supported in browser version of superagent"), this }, Request.prototype.pipe = Request.prototype.write = function () { throw Error("Streaming is not supported in browser version of superagent") }, Request.prototype._isHost = function (obj) { return obj && "object" == typeof obj && !Array.isArray(obj) && "[object Object]" !== Object.prototype.toString.call(obj) }, Request.prototype.end = function (fn) { return this._endCalled && console.warn("Warning: .end() was called twice. This is not supported in superagent"), this._endCalled = !0, this._callback = fn || noop, this._finalizeQueryString(), this._end() }, Request.prototype._end = function () { var self = this, xhr = this.xhr = request.getXHR(), data = this._formData || this._data; this._setTimeouts(), xhr.onreadystatechange = function () { var readyState = xhr.readyState; if (readyState >= 2 && self._responseTimeoutTimer && clearTimeout(self._responseTimeoutTimer), 4 == readyState) { var status; try { status = xhr.status } catch (e) { status = 0 } if (!status) { if (self.timedout || self._aborted) return; return self.crossDomainError() } self.emit("end") } }; var handleProgress = function (direction, e) { e.total > 0 && (e.percent = e.loaded / e.total * 100), e.direction = direction, self.emit("progress", e) }; if (this.hasListeners("progress")) try { xhr.onprogress = handleProgress.bind(null, "download"), xhr.upload && (xhr.upload.onprogress = handleProgress.bind(null, "upload")) } catch (e) { } try { this.username && this.password ? xhr.open(this.method, this.url, !0, this.username, this.password) : xhr.open(this.method, this.url, !0) } catch (err) { return this.callback(err) } if (this._withCredentials && (xhr.withCredentials = !0), !this._formData && "GET" != this.method && "HEAD" != this.method && "string" != typeof data && !this._isHost(data)) { var contentType = this._header["content-type"], serialize = this._serializer || request.serialize[contentType ? contentType.split(";")[0] : ""]; !serialize && isJSON(contentType) && (serialize = request.serialize["application/json"]), serialize && (data = serialize(data)) } for (var field in this.header) null != this.header[field] && this.header.hasOwnProperty(field) && xhr.setRequestHeader(field, this.header[field]); return this._responseType && (xhr.responseType = this._responseType), this.emit("request", this), xhr.send("undefined" != typeof data ? data : null), this }, request.agent = function () { return new Agent }, ["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(function (method) { Agent.prototype[method.toLowerCase()] = function (url, fn) { var req = new request.Request(method, url); return this._setDefaults(req), fn && req.end(fn), req } }), Agent.prototype.del = Agent.prototype["delete"], request.get = function (url, data, fn) { var req = request("GET", url); return "function" == typeof data && (fn = data, data = null), data && req.query(data), fn && req.end(fn), req }, request.head = function (url, data, fn) { var req = request("HEAD", url); return "function" == typeof data && (fn = data, data = null), data && req.query(data), fn && req.end(fn), req }, request.options = function (url, data, fn) { var req = request("OPTIONS", url); return "function" == typeof data && (fn = data, data = null), data && req.send(data), fn && req.end(fn), req }, request.del = del, request["delete"] = del, request.patch = function (url, data, fn) { var req = request("PATCH", url); return "function" == typeof data && (fn = data, data = null), data && req.send(data), fn && req.end(fn), req }, request.post = function (url, data, fn) { var req = request("POST", url); return "function" == typeof data && (fn = data, data = null), data && req.send(data), fn && req.end(fn), req }, request.put = function (url, data, fn) { var req = request("PUT", url); return "function" == typeof data && (fn = data, data = null), data && req.send(data), fn && req.end(fn), req }
}, function (module, exports, __webpack_require__) { function Emitter(obj) { if (obj) return mixin(obj) } function mixin(obj) { for (var key in Emitter.prototype) obj[key] = Emitter.prototype[key]; return obj } module.exports = Emitter, Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) { return this._callbacks = this._callbacks || {}, (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn), this }, Emitter.prototype.once = function (event, fn) { function on() { this.off(event, on), fn.apply(this, arguments) } return on.fn = fn, this.on(event, on), this }, Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) { if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this; var callbacks = this._callbacks["$" + event]; if (!callbacks) return this; if (1 == arguments.length) return delete this._callbacks["$" + event], this; for (var cb, i = 0; i < callbacks.length; i++)if (cb = callbacks[i], cb === fn || cb.fn === fn) { callbacks.splice(i, 1); break } return this }, Emitter.prototype.emit = function (event) { this._callbacks = this._callbacks || {}; var args = [].slice.call(arguments, 1), callbacks = this._callbacks["$" + event]; if (callbacks) { callbacks = callbacks.slice(0); for (var i = 0, len = callbacks.length; i < len; ++i)callbacks[i].apply(this, args) } return this }, Emitter.prototype.listeners = function (event) { return this._callbacks = this._callbacks || {}, this._callbacks["$" + event] || [] }, Emitter.prototype.hasListeners = function (event) { return !!this.listeners(event).length } }, function (module, exports, __webpack_require__) { "use strict"; function RequestBase(obj) { if (obj) return mixin(obj) } function mixin(obj) { for (var key in RequestBase.prototype) obj[key] = RequestBase.prototype[key]; return obj } var isObject = __webpack_require__(14); module.exports = RequestBase, RequestBase.prototype.clearTimeout = function () { return clearTimeout(this._timer), clearTimeout(this._responseTimeoutTimer), delete this._timer, delete this._responseTimeoutTimer, this }, RequestBase.prototype.parse = function (fn) { return this._parser = fn, this }, RequestBase.prototype.responseType = function (val) { return this._responseType = val, this }, RequestBase.prototype.serialize = function (fn) { return this._serializer = fn, this }, RequestBase.prototype.timeout = function (options) { if (!options || "object" != typeof options) return this._timeout = options, this._responseTimeout = 0, this; for (var option in options) switch (option) { case "deadline": this._timeout = options.deadline; break; case "response": this._responseTimeout = options.response; break; default: console.warn("Unknown timeout option", option) }return this }, RequestBase.prototype.retry = function (count, fn) { return 0 !== arguments.length && count !== !0 || (count = 1), count <= 0 && (count = 0), this._maxRetries = count, this._retries = 0, this._retryCallback = fn, this }; var ERROR_CODES = ["ECONNRESET", "ETIMEDOUT", "EADDRINFO", "ESOCKETTIMEDOUT"]; RequestBase.prototype._shouldRetry = function (err, res) { if (!this._maxRetries || this._retries++ >= this._maxRetries) return !1; if (this._retryCallback) try { var override = this._retryCallback(err, res); if (override === !0) return !0; if (override === !1) return !1 } catch (e) { console.error(e) } if (res && res.status && res.status >= 500 && 501 != res.status) return !0; if (err) { if (err.code && ~ERROR_CODES.indexOf(err.code)) return !0; if (err.timeout && "ECONNABORTED" == err.code) return !0; if (err.crossDomain) return !0 } return !1 }, RequestBase.prototype._retry = function () { return this.clearTimeout(), this.req && (this.req = null, this.req = this.request()), this._aborted = !1, this.timedout = !1, this._end() }, RequestBase.prototype.then = function (resolve, reject) { if (!this._fullfilledPromise) { var self = this; this._endCalled && console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises"), this._fullfilledPromise = new Promise(function (innerResolve, innerReject) { self.end(function (err, res) { err ? innerReject(err) : innerResolve(res) }) }) } return this._fullfilledPromise.then(resolve, reject) }, RequestBase.prototype["catch"] = function (cb) { return this.then(void 0, cb) }, RequestBase.prototype.use = function (fn) { return fn(this), this }, RequestBase.prototype.ok = function (cb) { if ("function" != typeof cb) throw Error("Callback required"); return this._okCallback = cb, this }, RequestBase.prototype._isResponseOK = function (res) { return !!res && (this._okCallback ? this._okCallback(res) : res.status >= 200 && res.status < 300) }, RequestBase.prototype.get = function (field) { return this._header[field.toLowerCase()] }, RequestBase.prototype.getHeader = RequestBase.prototype.get, RequestBase.prototype.set = function (field, val) { if (isObject(field)) { for (var key in field) this.set(key, field[key]); return this } return this._header[field.toLowerCase()] = val, this.header[field] = val, this }, RequestBase.prototype.unset = function (field) { return delete this._header[field.toLowerCase()], delete this.header[field], this }, RequestBase.prototype.field = function (name, val) { if (null === name || void 0 === name) throw new Error(".field(name, val) name can not be empty"); if (this._data && console.error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()"), isObject(name)) { for (var key in name) this.field(key, name[key]); return this } if (Array.isArray(val)) { for (var i in val) this.field(name, val[i]); return this } if (null === val || void 0 === val) throw new Error(".field(name, val) val can not be empty"); return "boolean" == typeof val && (val = "" + val), this._getFormData().append(name, val), this }, RequestBase.prototype.abort = function () { return this._aborted ? this : (this._aborted = !0, this.xhr && this.xhr.abort(), this.req && this.req.abort(), this.clearTimeout(), this.emit("abort"), this) }, RequestBase.prototype._auth = function (user, pass, options, base64Encoder) { switch (options.type) { case "basic": this.set("Authorization", "Basic " + base64Encoder(user + ":" + pass)); break; case "auto": this.username = user, this.password = pass; break; case "bearer": this.set("Authorization", "Bearer " + user) }return this }, RequestBase.prototype.withCredentials = function (on) { return void 0 == on && (on = !0), this._withCredentials = on, this }, RequestBase.prototype.redirects = function (n) { return this._maxRedirects = n, this }, RequestBase.prototype.maxResponseSize = function (n) { if ("number" != typeof n) throw TypeError("Invalid argument"); return this._maxResponseSize = n, this }, RequestBase.prototype.toJSON = function () { return { method: this.method, url: this.url, data: this._data, headers: this._header } }, RequestBase.prototype.send = function (data) { var isObj = isObject(data), type = this._header["content-type"]; if (this._formData && console.error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()"), isObj && !this._data) Array.isArray(data) ? this._data = [] : this._isHost(data) || (this._data = {}); else if (data && this._data && this._isHost(this._data)) throw Error("Can't merge these send calls"); if (isObj && isObject(this._data)) for (var key in data) this._data[key] = data[key]; else "string" == typeof data ? (type || this.type("form"), type = this._header["content-type"], "application/x-www-form-urlencoded" == type ? this._data = this._data ? this._data + "&" + data : data : this._data = (this._data || "") + data) : this._data = data; return !isObj || this._isHost(data) ? this : (type || this.type("json"), this) }, RequestBase.prototype.sortQuery = function (sort) { return this._sort = "undefined" == typeof sort || sort, this }, RequestBase.prototype._finalizeQueryString = function () { var query = this._query.join("&"); if (query && (this.url += (this.url.indexOf("?") >= 0 ? "&" : "?") + query), this._query.length = 0, this._sort) { var index = this.url.indexOf("?"); if (index >= 0) { var queryArr = this.url.substring(index + 1).split("&"); "function" == typeof this._sort ? queryArr.sort(this._sort) : queryArr.sort(), this.url = this.url.substring(0, index) + "?" + queryArr.join("&") } } }, RequestBase.prototype._appendQueryString = function () { console.trace("Unsupported") }, RequestBase.prototype._timeoutError = function (reason, timeout, errno) { if (!this._aborted) { var err = new Error(reason + timeout + "ms exceeded"); err.timeout = timeout, err.code = "ECONNABORTED", err.errno = errno, this.timedout = !0, this.abort(), this.callback(err) } }, RequestBase.prototype._setTimeouts = function () { var self = this; this._timeout && !this._timer && (this._timer = setTimeout(function () { self._timeoutError("Timeout of ", self._timeout, "ETIME") }, this._timeout)), this._responseTimeout && !this._responseTimeoutTimer && (this._responseTimeoutTimer = setTimeout(function () { self._timeoutError("Response timeout of ", self._responseTimeout, "ETIMEDOUT") }, this._responseTimeout)) } }, function (module, exports) { "use strict"; function isObject(obj) { return null !== obj && "object" == typeof obj } module.exports = isObject }, function (module, exports, __webpack_require__) { "use strict"; function ResponseBase(obj) { if (obj) return mixin(obj) } function mixin(obj) { for (var key in ResponseBase.prototype) obj[key] = ResponseBase.prototype[key]; return obj } var utils = __webpack_require__(16); module.exports = ResponseBase, ResponseBase.prototype.get = function (field) { return this.header[field.toLowerCase()] }, ResponseBase.prototype._setHeaderProperties = function (header) { var ct = header["content-type"] || ""; this.type = utils.type(ct); var params = utils.params(ct); for (var key in params) this[key] = params[key]; this.links = {}; try { header.link && (this.links = utils.parseLinks(header.link)) } catch (err) { } }, ResponseBase.prototype._setStatusProperties = function (status) { var type = status / 100 | 0; this.status = this.statusCode = status, this.statusType = type, this.info = 1 == type, this.ok = 2 == type, this.redirect = 3 == type, this.clientError = 4 == type, this.serverError = 5 == type, this.error = (4 == type || 5 == type) && this.toError(), this.created = 201 == status, this.accepted = 202 == status, this.noContent = 204 == status, this.badRequest = 400 == status, this.unauthorized = 401 == status, this.notAcceptable = 406 == status, this.forbidden = 403 == status, this.notFound = 404 == status, this.unprocessableEntity = 422 == status } }, function (module, exports) { "use strict"; exports.type = function (str) { return str.split(/ *; */).shift() }, exports.params = function (str) { return str.split(/ *; */).reduce(function (obj, str) { var parts = str.split(/ *= */), key = parts.shift(), val = parts.shift(); return key && val && (obj[key] = val), obj }, {}) }, exports.parseLinks = function (str) { return str.split(/ *, */).reduce(function (obj, str) { var parts = str.split(/ *; */), url = parts[0].slice(1, -1), rel = parts[1].split(/ *= */)[1].slice(1, -1); return obj[rel] = url, obj }, {}) }, exports.cleanHeader = function (header, changesOrigin) { return delete header["content-type"], delete header["content-length"], delete header["transfer-encoding"], delete header.host, changesOrigin && (delete header.authorization, delete header.cookie), header } }, function (module, exports) { function Agent() { this._defaults = [] } ["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects", "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert"].forEach(function (fn) { Agent.prototype[fn] = function () { return this._defaults.push({ fn: fn, arguments: arguments }), this } }), Agent.prototype._setDefaults = function (req) { this._defaults.forEach(function (def) { req[def.fn].apply(req, def.arguments) }) }, module.exports = Agent }, function (module, exports, __webpack_require__) { function padding(str) { var mod = str.length % 4, pad = 4 - mod; return 0 === mod ? str : str + new Array(1 + pad).join("=") } function stringToByteArray(str) { for (var arr = new Array(str.length), a = 0; a < str.length; a++)arr[a] = str.charCodeAt(a); return arr } function byteArrayToString(array) { for (var result = "", i = 0; i < array.length; i++)result += String.fromCharCode(array[i]); return result } function encode(str) { return base64.fromByteArray(stringToByteArray(str)).replace(/\+/g, "-").replace(/\//g, "_") } function decode(str) { return str = padding(str).replace(/-/g, "+").replace(/_/g, "/"), byteArrayToString(base64.toByteArray(str)) } var base64 = __webpack_require__(19); module.exports = { encode: encode, decode: decode } }, function (module, exports) { "use strict"; function getLens(b64) { var len = b64.length; if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4"); var validLen = b64.indexOf("="); validLen === -1 && (validLen = len); var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4; return [validLen, placeHoldersLen] } function byteLength(b64) { var lens = getLens(b64), validLen = lens[0], placeHoldersLen = lens[1]; return 3 * (validLen + placeHoldersLen) / 4 - placeHoldersLen } function _byteLength(b64, validLen, placeHoldersLen) { return 3 * (validLen + placeHoldersLen) / 4 - placeHoldersLen } function toByteArray(b64) { for (var tmp, lens = getLens(b64), validLen = lens[0], placeHoldersLen = lens[1], arr = new Arr(_byteLength(b64, validLen, placeHoldersLen)), curByte = 0, len = placeHoldersLen > 0 ? validLen - 4 : validLen, i = 0; i < len; i += 4)tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)], arr[curByte++] = tmp >> 16 & 255, arr[curByte++] = tmp >> 8 & 255, arr[curByte++] = 255 & tmp; return 2 === placeHoldersLen && (tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4, arr[curByte++] = 255 & tmp), 1 === placeHoldersLen && (tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2, arr[curByte++] = tmp >> 8 & 255, arr[curByte++] = 255 & tmp), arr } function tripletToBase64(num) { return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[63 & num] } function encodeChunk(uint8, start, end) { for (var tmp, output = [], i = start; i < end; i += 3)tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (255 & uint8[i + 2]), output.push(tripletToBase64(tmp)); return output.join("") } function fromByteArray(uint8) { for (var tmp, len = uint8.length, extraBytes = len % 3, parts = [], maxChunkLength = 16383, i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength)); return 1 === extraBytes ? (tmp = uint8[len - 1], parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==")) : 2 === extraBytes && (tmp = (uint8[len - 2] << 8) + uint8[len - 1], parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=")), parts.join("") } exports.byteLength = byteLength, exports.toByteArray = toByteArray, exports.fromByteArray = fromByteArray; for (var lookup = [], revLookup = [], Arr = "undefined" != typeof Uint8Array ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i = 0, len = code.length; i < len; ++i)lookup[i] = code[i], revLookup[code.charCodeAt(i)] = i; revLookup["-".charCodeAt(0)] = 62, revLookup["_".charCodeAt(0)] = 63 }, function (module, exports) { module.exports = { raw: "8.9.1" } }, function (module, exports, __webpack_require__) { "use strict"; var stringify = __webpack_require__(22), parse = __webpack_require__(25), formats = __webpack_require__(24); module.exports = { formats: formats, parse: parse, stringify: stringify } }, function (module, exports, __webpack_require__) { "use strict"; var utils = __webpack_require__(23), formats = __webpack_require__(24), arrayPrefixGenerators = { brackets: function (prefix) { return prefix + "[]" }, indices: function (prefix, key) { return prefix + "[" + key + "]" }, repeat: function (prefix) { return prefix } }, toISO = Date.prototype.toISOString, defaults = { delimiter: "&", encode: !0, encoder: utils.encode, encodeValuesOnly: !1, serializeDate: function (date) { return toISO.call(date) }, skipNulls: !1, strictNullHandling: !1 }, stringify = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly) { var obj = object; if ("function" == typeof filter) obj = filter(prefix, obj); else if (obj instanceof Date) obj = serializeDate(obj); else if (null === obj) { if (strictNullHandling) return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder) : prefix; obj = "" } if ("string" == typeof obj || "number" == typeof obj || "boolean" == typeof obj || utils.isBuffer(obj)) { if (encoder) { var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder); return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder))] } return [formatter(prefix) + "=" + formatter(String(obj))] } var values = []; if ("undefined" == typeof obj) return values; var objKeys; if (Array.isArray(filter)) objKeys = filter; else { var keys = Object.keys(obj); objKeys = sort ? keys.sort(sort) : keys } for (var i = 0; i < objKeys.length; ++i) { var key = objKeys[i]; skipNulls && null === obj[key] || (values = Array.isArray(obj) ? values.concat(stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly)) : values.concat(stringify(obj[key], prefix + (allowDots ? "." + key : "[" + key + "]"), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly))) } return values }; module.exports = function (object, opts) { var obj = object, options = opts ? utils.assign({}, opts) : {}; if (null !== options.encoder && void 0 !== options.encoder && "function" != typeof options.encoder) throw new TypeError("Encoder has to be a function."); var delimiter = "undefined" == typeof options.delimiter ? defaults.delimiter : options.delimiter, strictNullHandling = "boolean" == typeof options.strictNullHandling ? options.strictNullHandling : defaults.strictNullHandling, skipNulls = "boolean" == typeof options.skipNulls ? options.skipNulls : defaults.skipNulls, encode = "boolean" == typeof options.encode ? options.encode : defaults.encode, encoder = "function" == typeof options.encoder ? options.encoder : defaults.encoder, sort = "function" == typeof options.sort ? options.sort : null, allowDots = "undefined" != typeof options.allowDots && options.allowDots, serializeDate = "function" == typeof options.serializeDate ? options.serializeDate : defaults.serializeDate, encodeValuesOnly = "boolean" == typeof options.encodeValuesOnly ? options.encodeValuesOnly : defaults.encodeValuesOnly; if ("undefined" == typeof options.format) options.format = formats["default"]; else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) throw new TypeError("Unknown format option provided."); var objKeys, filter, formatter = formats.formatters[options.format]; "function" == typeof options.filter ? (filter = options.filter, obj = filter("", obj)) : Array.isArray(options.filter) && (filter = options.filter, objKeys = filter); var keys = []; if ("object" != typeof obj || null === obj) return ""; var arrayFormat; arrayFormat = options.arrayFormat in arrayPrefixGenerators ? options.arrayFormat : "indices" in options ? options.indices ? "indices" : "repeat" : "indices"; var generateArrayPrefix = arrayPrefixGenerators[arrayFormat]; objKeys || (objKeys = Object.keys(obj)), sort && objKeys.sort(sort); for (var i = 0; i < objKeys.length; ++i) { var key = objKeys[i]; skipNulls && null === obj[key] || (keys = keys.concat(stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encode ? encoder : null, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly))) } var joined = keys.join(delimiter), prefix = options.addQueryPrefix === !0 ? "?" : ""; return joined.length > 0 ? prefix + joined : "" } }, function (module, exports) { "use strict"; var has = Object.prototype.hasOwnProperty, hexTable = function () { for (var array = [], i = 0; i < 256; ++i)array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase()); return array }(), compactQueue = function (queue) { for (var obj; queue.length;) { var item = queue.pop(); if (obj = item.obj[item.prop], Array.isArray(obj)) { for (var compacted = [], j = 0; j < obj.length; ++j)"undefined" != typeof obj[j] && compacted.push(obj[j]); item.obj[item.prop] = compacted } } return obj }, arrayToObject = function (source, options) { for (var obj = options && options.plainObjects ? Object.create(null) : {}, i = 0; i < source.length; ++i)"undefined" != typeof source[i] && (obj[i] = source[i]); return obj }, merge = function merge(target, source, options) { if (!source) return target; if ("object" != typeof source) { if (Array.isArray(target)) target.push(source); else { if ("object" != typeof target) return [target, source]; (options.plainObjects || options.allowPrototypes || !has.call(Object.prototype, source)) && (target[source] = !0) } return target } if ("object" != typeof target) return [target].concat(source); var mergeTarget = target; return Array.isArray(target) && !Array.isArray(source) && (mergeTarget = arrayToObject(target, options)), Array.isArray(target) && Array.isArray(source) ? (source.forEach(function (item, i) { has.call(target, i) ? target[i] && "object" == typeof target[i] ? target[i] = merge(target[i], item, options) : target.push(item) : target[i] = item }), target) : Object.keys(source).reduce(function (acc, key) { var value = source[key]; return has.call(acc, key) ? acc[key] = merge(acc[key], value, options) : acc[key] = value, acc }, mergeTarget) }, assign = function (target, source) { return Object.keys(source).reduce(function (acc, key) { return acc[key] = source[key], acc }, target) }, decode = function (str) { try { return decodeURIComponent(str.replace(/\+/g, " ")) } catch (e) { return str } }, encode = function (str) { if (0 === str.length) return str; for (var string = "string" == typeof str ? str : String(str), out = "", i = 0; i < string.length; ++i) { var c = string.charCodeAt(i); 45 === c || 46 === c || 95 === c || 126 === c || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 ? out += string.charAt(i) : c < 128 ? out += hexTable[c] : c < 2048 ? out += hexTable[192 | c >> 6] + hexTable[128 | 63 & c] : c < 55296 || c >= 57344 ? out += hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | 63 & c] : (i += 1, c = 65536 + ((1023 & c) << 10 | 1023 & string.charCodeAt(i)), out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | 63 & c]) } return out }, compact = function (value) { for (var queue = [{ obj: { o: value }, prop: "o" }], refs = [], i = 0; i < queue.length; ++i)for (var item = queue[i], obj = item.obj[item.prop], keys = Object.keys(obj), j = 0; j < keys.length; ++j) { var key = keys[j], val = obj[key]; "object" == typeof val && null !== val && refs.indexOf(val) === -1 && (queue.push({ obj: obj, prop: key }), refs.push(val)) } return compactQueue(queue) }, isRegExp = function (obj) { return "[object RegExp]" === Object.prototype.toString.call(obj) }, isBuffer = function (obj) { return null !== obj && "undefined" != typeof obj && !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj)) }; module.exports = { arrayToObject: arrayToObject, assign: assign, compact: compact, decode: decode, encode: encode, isBuffer: isBuffer, isRegExp: isRegExp, merge: merge } }, function (module, exports) { "use strict"; var replace = String.prototype.replace, percentTwenties = /%20/g; module.exports = { "default": "RFC3986", formatters: { RFC1738: function (value) { return replace.call(value, percentTwenties, "+") }, RFC3986: function (value) { return value } }, RFC1738: "RFC1738", RFC3986: "RFC3986" } }, function (module, exports, __webpack_require__) {
  "use strict"; var utils = __webpack_require__(23), has = Object.prototype.hasOwnProperty, defaults = { allowDots: !1, allowPrototypes: !1, arrayLimit: 20, decoder: utils.decode, delimiter: "&", depth: 5, parameterLimit: 1e3, plainObjects: !1, strictNullHandling: !1 }, parseValues = function (str, options) { for (var obj = {}, cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str, limit = options.parameterLimit === 1 / 0 ? void 0 : options.parameterLimit, parts = cleanStr.split(options.delimiter, limit), i = 0; i < parts.length; ++i) { var key, val, part = parts[i], bracketEqualsPos = part.indexOf("]="), pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1; pos === -1 ? (key = options.decoder(part, defaults.decoder), val = options.strictNullHandling ? null : "") : (key = options.decoder(part.slice(0, pos), defaults.decoder), val = options.decoder(part.slice(pos + 1), defaults.decoder)), has.call(obj, key) ? obj[key] = [].concat(obj[key]).concat(val) : obj[key] = val } return obj }, parseObject = function (chain, val, options) { for (var leaf = val, i = chain.length - 1; i >= 0; --i) { var obj, root = chain[i]; if ("[]" === root) obj = [], obj = obj.concat(leaf); else { obj = options.plainObjects ? Object.create(null) : {}; var cleanRoot = "[" === root.charAt(0) && "]" === root.charAt(root.length - 1) ? root.slice(1, -1) : root, index = parseInt(cleanRoot, 10); !isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit ? (obj = [], obj[index] = leaf) : obj[cleanRoot] = leaf } leaf = obj } return leaf }, parseKeys = function (givenKey, val, options) { if (givenKey) { var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey, brackets = /(\[[^[\]]*])/, child = /(\[[^[\]]*])/g, segment = brackets.exec(key), parent = segment ? key.slice(0, segment.index) : key, keys = []; if (parent) { if (!options.plainObjects && has.call(Object.prototype, parent) && !options.allowPrototypes) return; keys.push(parent) } for (var i = 0; null !== (segment = child.exec(key)) && i < options.depth;) { if (i += 1, !options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1)) && !options.allowPrototypes) return; keys.push(segment[1]) } return segment && keys.push("[" + key.slice(segment.index) + "]"), parseObject(keys, val, options) } }; module.exports = function (str, opts) {
    var options = opts ? utils.assign({}, opts) : {}; if (null !== options.decoder && void 0 !== options.decoder && "function" != typeof options.decoder) throw new TypeError("Decoder has to be a function."); if (options.ignoreQueryPrefix = options.ignoreQueryPrefix === !0, options.delimiter = "string" == typeof options.delimiter || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter, options.depth = "number" == typeof options.depth ? options.depth : defaults.depth, options.arrayLimit = "number" == typeof options.arrayLimit ? options.arrayLimit : defaults.arrayLimit,
      options.parseArrays = options.parseArrays !== !1, options.decoder = "function" == typeof options.decoder ? options.decoder : defaults.decoder, options.allowDots = "boolean" == typeof options.allowDots ? options.allowDots : defaults.allowDots, options.plainObjects = "boolean" == typeof options.plainObjects ? options.plainObjects : defaults.plainObjects, options.allowPrototypes = "boolean" == typeof options.allowPrototypes ? options.allowPrototypes : defaults.allowPrototypes, options.parameterLimit = "number" == typeof options.parameterLimit ? options.parameterLimit : defaults.parameterLimit, options.strictNullHandling = "boolean" == typeof options.strictNullHandling ? options.strictNullHandling : defaults.strictNullHandling, "" === str || null === str || "undefined" == typeof str) return options.plainObjects ? Object.create(null) : {}; for (var tempObj = "string" == typeof str ? parseValues(str, options) : str, obj = options.plainObjects ? Object.create(null) : {}, keys = Object.keys(tempObj), i = 0; i < keys.length; ++i) { var key = keys[i], newObj = parseKeys(key, tempObj[key], options); obj = utils.merge(obj, newObj, options) } return utils.compact(obj)
  }
}, function (module, exports, __webpack_require__) { function pick(object, keys) { return keys.reduce(function (prev, key) { return object[key] && (prev[key] = object[key]), prev }, {}) } function getKeysNotIn(obj, allowedKeys) { var notAllowed = []; for (var key in obj) allowedKeys.indexOf(key) === -1 && notAllowed.push(key); return notAllowed } function objectValues(obj) { var values = []; for (var key in obj) values.push(obj[key]); return values } function extend() { var params = objectValues(arguments); return params.unshift({}), objectAssign.get().apply(void 0, params) } function merge(object, keys) { return { base: keys ? pick(object, keys) : object, "with": function (object2, keys2) { return object2 = keys2 ? pick(object2, keys2) : object2, extend(this.base, object2) } } } function blacklist(object, blacklistedKeys) { return Object.keys(object).reduce(function (p, key) { return blacklistedKeys.indexOf(key) === -1 && (p[key] = object[key]), p }, {}) } function camelToSnake(str) { for (var code, newKey = "", index = 0, wasPrevNumber = !0, wasPrevUppercase = !0; index < str.length;)code = str.charCodeAt(index), !wasPrevUppercase && code >= 65 && code <= 90 || !wasPrevNumber && code >= 48 && code <= 57 ? (newKey += "_", newKey += str[index].toLowerCase()) : newKey += str[index].toLowerCase(), wasPrevNumber = code >= 48 && code <= 57, wasPrevUppercase = code >= 65 && code <= 90, index++; return newKey } function snakeToCamel(str) { var parts = str.split("_"); return parts.reduce(function (p, c) { return p + c.charAt(0).toUpperCase() + c.slice(1) }, parts.shift()) } function toSnakeCase(object, exceptions) { return "object" != typeof object || assert.isArray(object) || null === object ? object : (exceptions = exceptions || [], Object.keys(object).reduce(function (p, key) { var newKey = exceptions.indexOf(key) === -1 ? camelToSnake(key) : key; return p[newKey] = toSnakeCase(object[key]), p }, {})) } function toCamelCase(object, exceptions) { return "object" != typeof object || assert.isArray(object) || null === object ? object : (exceptions = exceptions || [], Object.keys(object).reduce(function (p, key) { var newKey = exceptions.indexOf(key) === -1 ? snakeToCamel(key) : key; return p[newKey] = toCamelCase(object[key]), p }, {})) } var assert = __webpack_require__(27), objectAssign = __webpack_require__(28); module.exports = { toSnakeCase: toSnakeCase, toCamelCase: toCamelCase, blacklist: blacklist, merge: merge, pick: pick, getKeysNotIn: getKeysNotIn, extend: extend } }, function (module, exports) { function attribute(o, attr, type, text) { if (type = "array" === type ? "object" : type, o && typeof o[attr] !== type) throw new Error(text) } function variable(o, type, text) { if (typeof o !== type) throw new Error(text) } function value(o, values, text) { if (values.indexOf(o) === -1) throw new Error(text) } function check(o, config, attributes) { if (config.optional && !o || variable(o, config.type, config.message), "object" === config.type && attributes) for (var keys = Object.keys(attributes), index = 0; index < keys.length; index++) { var a = keys[index]; attributes[a].optional && !o[a] || attributes[a].condition && !attributes[a].condition(o) || (attribute(o, a, attributes[a].type, attributes[a].message), attributes[a].values && value(o[a], attributes[a].values, attributes[a].value_message)) } } function isArray(array) { return this.supportsIsArray() ? Array.isArray(array) : "[object Array]" === toString.call(array) } function supportsIsArray() { return null != Array.isArray } var toString = Object.prototype.toString; module.exports = { check: check, attribute: attribute, variable: variable, value: value, isArray: isArray, supportsIsArray: supportsIsArray } }, function (module, exports) { function get() { return Object.assign ? Object.assign : objectAssignPolyfill } function objectAssignPolyfill(target) { "use strict"; if (void 0 === target || null === target) throw new TypeError("Cannot convert first argument to object"); for (var to = Object(target), i = 1; i < arguments.length; i++) { var nextSource = arguments[i]; if (void 0 !== nextSource && null !== nextSource) for (var keysArray = Object.keys(Object(nextSource)), nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) { var nextKey = keysArray[nextIndex], desc = Object.getOwnPropertyDescriptor(nextSource, nextKey); void 0 !== desc && desc.enumerable && (to[nextKey] = nextSource[nextKey]) } } return to } module.exports = { get: get, objectAssignPolyfill: objectAssignPolyfill } }, function (module, exports, __webpack_require__) { function wrapCallback(cb, options) { return options = options || {}, options.ignoreCasing = !!options.ignoreCasing && options.ignoreCasing, function (err, data) { var errObj; return err || data ? (!err && data.err && (err = data.err, data = null), !err && data.error && (err = data, data = null), err ? (errObj = { original: err }, err.response && err.response.statusCode && (errObj.statusCode = err.response.statusCode), err.response && err.response.statusText && (errObj.statusText = err.response.statusText), err.response && err.response.body && (err = err.response.body), err.err && (err = err.err), errObj.code = err.error || err.code || err.error_code || err.status || null, errObj.description = err.errorDescription || err.error_description || err.description || err.error || err.details || err.err || null, err.name && (errObj.name = err.name), err.policy && (errObj.policy = err.policy), cb(errObj)) : !data.type || "text/html" !== data.type && "text/plain" !== data.type ? options.ignoreCasing ? cb(null, data.body || data) : cb(null, objectHelper.toCamelCase(data.body || data)) : cb(null, data.text)) : cb(error.buildResponse("generic_error", "Something went wrong")) } } var error = __webpack_require__(30), objectHelper = __webpack_require__(26); module.exports = wrapCallback }, function (module, exports) { function buildResponse(error, description) { return { error: error, errorDescription: description } } function invalidJwt(description) { return buildResponse("invalid_token", description) } module.exports = { buildResponse: buildResponse, invalidJwt: invalidJwt } }, function (module, exports, __webpack_require__) { function oauthAuthorizeParams(warn, params) { var notAllowed = objectHelper.getKeysNotIn(params, authorizeParams); return notAllowed.length > 0 && warn.warning("Following parameters are not allowed on the `/authorize` endpoint: [" + notAllowed.join(",") + "]"), params } function oauthTokenParams(warn, params) { return objectHelper.pick(params, tokenParams) } var objectHelper = __webpack_require__(26), tokenParams = ["realm", "audience", "client_id", "client_secret", "redirect_uri", "scope", "code", "grant_type", "username", "password", "refresh_token", "assertion", "client_assertion", "client_assertion_type", "code_verifier"], authorizeParams = ["connection", "connection_scope", "auth0Client", "owp", "device", "protocol", "_csrf", "_intstate", "login_ticket", "client_id", "response_type", "response_mode", "redirect_uri", "audience", "scope", "state", "nonce", "display", "prompt", "max_age", "ui_locales", "claims_locales", "id_token_hint", "login_hint", "acr_values", "claims", "registration", "request", "request_uri", "code_challenge", "code_challenge_method"]; module.exports = { oauthTokenParams: oauthTokenParams, oauthAuthorizeParams: oauthAuthorizeParams } }, function (module, exports) { function Warn(options) { this.disableWarnings = options.disableWarnings } Warn.prototype.warning = function (message) { this.disableWarnings || console.warn(message) }, module.exports = Warn }, function (module, exports, __webpack_require__) { function PasswordlessAuthentication(request, options) { this.baseOptions = options, this.request = request } var urljoin = __webpack_require__(9), objectHelper = __webpack_require__(26), assert = __webpack_require__(27), qs = __webpack_require__(21), responseHandler = __webpack_require__(29); PasswordlessAuthentication.prototype.buildVerifyUrl = function (options) { var params, qString; return assert.check(options, { type: "object", message: "options parameter is not valid" }, { connection: { type: "string", message: "connection option is required" }, verificationCode: { type: "string", message: "verificationCode option is required" }, phoneNumber: { optional: !1, type: "string", message: "phoneNumber option is required", condition: function (o) { return !o.email } }, email: { optional: !1, type: "string", message: "email option is required", condition: function (o) { return !o.phoneNumber } } }), params = objectHelper.merge(this.baseOptions, ["clientID", "responseType", "responseMode", "redirectUri", "scope", "audience", "_csrf", "state", "_intstate", "protocol", "nonce"])["with"](options), this.baseOptions._sendTelemetry && (params.auth0Client = this.request.getTelemetryData()), params = objectHelper.toSnakeCase(params, ["auth0Client"]), qString = qs.stringify(params), urljoin(this.baseOptions.rootUrl, "passwordless", "verify_redirect", "?" + qString) }, PasswordlessAuthentication.prototype.start = function (options, cb) { var url, body; return assert.check(options, { type: "object", message: "options parameter is not valid" }, { connection: { type: "string", message: "connection option is required" }, send: { type: "string", message: "send option is required", values: ["link", "code"], value_message: "send is not valid ([link, code])" }, phoneNumber: { optional: !0, type: "string", message: "phoneNumber option is required", condition: function (o) { return "code" === o.send || !o.email } }, email: { optional: !0, type: "string", message: "email option is required", condition: function (o) { return "link" === o.send || !o.phoneNumber } }, authParams: { optional: !0, type: "object", message: "authParams option is required" } }), assert.check(cb, { type: "function", message: "cb parameter is not valid" }), url = urljoin(this.baseOptions.rootUrl, "passwordless", "start"), body = objectHelper.merge(this.baseOptions, ["clientID", "responseType", "redirectUri", "scope"])["with"](options), body.scope && (body.authParams = body.authParams || {}, body.authParams.scope = body.scope), body.redirectUri && (body.authParams = body.authParams || {}, body.authParams.redirect_uri = body.redirectUri), body.responseType && (body.authParams = body.authParams || {}, body.authParams.response_type = body.responseType), delete body.redirectUri, delete body.responseType, delete body.scope, body = objectHelper.toSnakeCase(body, ["auth0Client", "authParams"]), this.request.post(url).send(body).end(responseHandler(cb)) }, PasswordlessAuthentication.prototype.verify = function (options, cb) { var url, cleanOption; return assert.check(options, { type: "object", message: "options parameter is not valid" }, { connection: { type: "string", message: "connection option is required" }, verificationCode: { type: "string", message: "verificationCode option is required" }, phoneNumber: { optional: !1, type: "string", message: "phoneNumber option is required", condition: function (o) { return !o.email } }, email: { optional: !1, type: "string", message: "email option is required", condition: function (o) { return !o.phoneNumber } } }), assert.check(cb, { type: "function", message: "cb parameter is not valid" }), cleanOption = objectHelper.pick(options, ["connection", "verificationCode", "phoneNumber", "email", "auth0Client"]), cleanOption = objectHelper.toSnakeCase(cleanOption, ["auth0Client"]), url = urljoin(this.baseOptions.rootUrl, "passwordless", "verify"), this.request.post(url).send(cleanOption).end(responseHandler(cb)) }, module.exports = PasswordlessAuthentication }, function (module, exports, __webpack_require__) { function DBConnection(request, options) { this.baseOptions = options, this.request = request } var urljoin = __webpack_require__(9), objectHelper = __webpack_require__(26), assert = __webpack_require__(27), responseHandler = __webpack_require__(29); DBConnection.prototype.signup = function (options, cb) { var url, body, metadata; return assert.check(options, { type: "object", message: "options parameter is not valid" }, { connection: { type: "string", message: "connection option is required" }, email: { type: "string", message: "email option is required" }, password: { type: "string", message: "password option is required" } }), assert.check(cb, { type: "function", message: "cb parameter is not valid" }), url = urljoin(this.baseOptions.rootUrl, "dbconnections", "signup"), body = objectHelper.merge(this.baseOptions, ["clientID"])["with"](options), metadata = body.user_metadata || body.userMetadata, body = objectHelper.blacklist(body, ["scope", "userMetadata", "user_metadata"]), body = objectHelper.toSnakeCase(body, ["auth0Client"]), metadata && (body.user_metadata = metadata), this.request.post(url).send(body).end(responseHandler(cb)) }, DBConnection.prototype.changePassword = function (options, cb) { var url, body; return assert.check(options, { type: "object", message: "options parameter is not valid" }, { connection: { type: "string", message: "connection option is required" }, email: { type: "string", message: "email option is required" } }), assert.check(cb, { type: "function", message: "cb parameter is not valid" }), url = urljoin(this.baseOptions.rootUrl, "dbconnections", "change_password"), body = objectHelper.merge(this.baseOptions, ["clientID"])["with"](options, ["email", "connection"]), body = objectHelper.toSnakeCase(body, ["auth0Client"]), this.request.post(url).send(body).end(responseHandler(cb)) }, module.exports = DBConnection }, function (module, exports, __webpack_require__) { function Management(options) { assert.check(options, { type: "object", message: "options parameter is not valid" }, { domain: { type: "string", message: "domain option is required" }, token: { type: "string", message: "token option is required" }, _sendTelemetry: { optional: !0, type: "boolean", message: "_sendTelemetry option is not valid" }, _telemetryInfo: { optional: !0, type: "object", message: "_telemetryInfo option is not valid" } }), this.baseOptions = options, this.baseOptions.headers = { Authorization: "Bearer " + this.baseOptions.token }, this.request = new RequestBuilder(this.baseOptions), this.baseOptions.rootUrl = urljoin("https://" + this.baseOptions.domain, "api", "v2") } var urljoin = __webpack_require__(9), RequestBuilder = __webpack_require__(10), assert = __webpack_require__(27), responseHandler = __webpack_require__(29); Management.prototype.getUser = function (userId, cb) { var url; return assert.check(userId, { type: "string", message: "userId parameter is not valid" }), assert.check(cb, { type: "function", message: "cb parameter is not valid" }), url = urljoin(this.baseOptions.rootUrl, "users", userId), this.request.get(url).end(responseHandler(cb, { ignoreCasing: !0 })) }, Management.prototype.patchUserMetadata = function (userId, userMetadata, cb) { var url; return assert.check(userId, { type: "string", message: "userId parameter is not valid" }), assert.check(userMetadata, { type: "object", message: "userMetadata parameter is not valid" }), assert.check(cb, { type: "function", message: "cb parameter is not valid" }), url = urljoin(this.baseOptions.rootUrl, "users", userId), this.request.patch(url).send({ user_metadata: userMetadata }).end(responseHandler(cb, { ignoreCasing: !0 })) }, Management.prototype.linkUser = function (userId, secondaryUserToken, cb) { var url; return assert.check(userId, { type: "string", message: "userId parameter is not valid" }), assert.check(secondaryUserToken, { type: "string", message: "secondaryUserToken parameter is not valid" }), assert.check(cb, { type: "function", message: "cb parameter is not valid" }), url = urljoin(this.baseOptions.rootUrl, "users", userId, "identities"), this.request.post(url).send({ link_with: secondaryUserToken }).end(responseHandler(cb, { ignoreCasing: !0 })) }, module.exports = Management }, function (module, exports, __webpack_require__) { function WebAuth(options) { assert.check(options, { type: "object", message: "options parameter is not valid" }, { domain: { type: "string", message: "domain option is required" }, clientID: { type: "string", message: "clientID option is required" }, responseType: { optional: !0, type: "string", message: "responseType is not valid" }, responseMode: { optional: !0, type: "string", message: "responseMode is not valid" }, redirectUri: { optional: !0, type: "string", message: "redirectUri is not valid" }, scope: { optional: !0, type: "string", message: "scope is not valid" }, audience: { optional: !0, type: "string", message: "audience is not valid" }, leeway: { optional: !0, type: "number", message: "leeway is not valid" }, plugins: { optional: !0, type: "array", message: "plugins is not valid" }, _disableDeprecationWarnings: { optional: !0, type: "boolean", message: "_disableDeprecationWarnings option is not valid" }, _sendTelemetry: { optional: !0, type: "boolean", message: "_sendTelemetry option is not valid" }, _telemetryInfo: { optional: !0, type: "object", message: "_telemetryInfo option is not valid" }, _timesToRetryFailedRequests: { optional: !0, type: "number", message: "_timesToRetryFailedRequests option is not valid" } }), options.overrides && assert.check(options.overrides, { type: "object", message: "overrides option is not valid" }, { __tenant: { type: "string", message: "__tenant option is required" }, __token_issuer: { type: "string", message: "__token_issuer option is required" } }), this.baseOptions = options, this.baseOptions.plugins = new PluginHandler(this, this.baseOptions.plugins || []), this.baseOptions._sendTelemetry = this.baseOptions._sendTelemetry !== !1 || this.baseOptions._sendTelemetry, this.baseOptions._timesToRetryFailedRequests = options._timesToRetryFailedRequests ? parseInt(options._timesToRetryFailedRequests, 0) : 0, this.baseOptions.tenant = this.baseOptions.overrides && this.baseOptions.overrides.__tenant || this.baseOptions.domain.split(".")[0], this.baseOptions.token_issuer = this.baseOptions.overrides && this.baseOptions.overrides.__token_issuer || "https://" + this.baseOptions.domain + "/", this.transactionManager = new TransactionManager(this.baseOptions.transaction), this.client = new Authentication(this.baseOptions), this.redirect = new Redirect(this.client, this.baseOptions), this.popup = new Popup(this, this.baseOptions), this.crossOriginAuthentication = new CrossOriginAuthentication(this, this.baseOptions) } function buildParseHashResponse(qsParams, appStatus, token) { return { accessToken: qsParams.access_token || null, idToken: qsParams.id_token || null, idTokenPayload: token || null, appStatus: appStatus || null, refreshToken: qsParams.refresh_token || null, state: qsParams.state || null, expiresIn: qsParams.expires_in ? parseInt(qsParams.expires_in, 10) : null, tokenType: qsParams.token_type || null, scope: qsParams.scope || null } } var IdTokenVerifier = __webpack_require__(37), assert = __webpack_require__(27), error = __webpack_require__(30), qs = __webpack_require__(21), PluginHandler = __webpack_require__(48), windowHelper = __webpack_require__(49), objectHelper = __webpack_require__(26), TransactionManager = __webpack_require__(50), Authentication = __webpack_require__(8), Redirect = __webpack_require__(57), Popup = __webpack_require__(59), SilentAuthenticationHandler = __webpack_require__(63), CrossOriginAuthentication = __webpack_require__(65); WebAuth.prototype.parseHash = function (options, cb) { var parsedQs, err, state, transaction, transactionNonce; cb || "function" != typeof options ? options = options || {} : (cb = options, options = {}), options._idTokenVerification = !(options._idTokenVerification === !1); var _window = windowHelper.getWindow(), hashStr = void 0 === options.hash ? _window.location.hash : options.hash; if (hashStr = hashStr.replace(/^#?\/?/, ""), parsedQs = qs.parse(hashStr), parsedQs.hasOwnProperty("error")) return err = error.buildResponse(parsedQs.error, parsedQs.error_description), parsedQs.state && (err.state = parsedQs.state), cb(err); if (!parsedQs.hasOwnProperty("access_token") && !parsedQs.hasOwnProperty("id_token") && !parsedQs.hasOwnProperty("refresh_token")) return cb(null, null); state = parsedQs.state || options.state, transaction = this.transactionManager.getStoredTransaction(state), transactionNonce = options.nonce || transaction && transaction.nonce || null; var applicationStatus = transaction && transaction.appStatus || null; if (parsedQs.id_token && options._idTokenVerification) return this.validateToken(parsedQs.id_token, transactionNonce, function (validationError, payload) { return validationError ? cb(validationError) : cb(null, buildParseHashResponse(parsedQs, applicationStatus, payload)) }); if (parsedQs.id_token) { var verifier = new IdTokenVerifier({ issuer: this.baseOptions.token_issuer, audience: this.baseOptions.clientID, leeway: this.baseOptions.leeway || 0, __disableExpirationCheck: this.baseOptions.__disableExpirationCheck }), decodedToken = verifier.decode(parsedQs.id_token); cb(null, buildParseHashResponse(parsedQs, applicationStatus, decodedToken.payload)) } else cb(null, buildParseHashResponse(parsedQs, applicationStatus, null)) }, WebAuth.prototype.validateToken = function (token, nonce, cb) { var verifier = new IdTokenVerifier({ issuer: this.baseOptions.token_issuer, audience: this.baseOptions.clientID, leeway: this.baseOptions.leeway || 0, __disableExpirationCheck: this.baseOptions.__disableExpirationCheck }); verifier.verify(token, nonce, function (err, payload) { return err ? cb(error.invalidJwt(err.message)) : void cb(null, payload) }) }, WebAuth.prototype.renewAuth = function (options, cb) { var handler, usePostMessage = !!options.usePostMessage, postMessageDataType = options.postMessageDataType || !1, _this = this, params = objectHelper.merge(this.baseOptions, ["clientID", "redirectUri", "responseType", "scope", "audience", "_csrf", "state", "_intstate", "nonce"])["with"](options); params.responseType = params.responseType || "token", params.responseMode = params.responseMode || "fragment", options.nonce || (params = this.transactionManager.process(params)), assert.check(params, { type: "object", message: "options parameter is not valid" }), assert.check(cb, { type: "function", message: "cb parameter is not valid" }), params.prompt = "none", params = objectHelper.blacklist(params, ["usePostMessage", "tenant", "postMessageDataType"]), handler = SilentAuthenticationHandler.create({ authenticationUrl: this.client.buildAuthorizeUrl(params), postMessageDataType: postMessageDataType }), handler.login(usePostMessage, function (err, hash) { if ("object" == typeof hash) return cb(err, hash); var transaction = _this.transactionManager.getStoredTransaction(params.state), transactionNonce = options.nonce || transaction && transaction.nonce || null, transactionState = options.state || transaction && transaction.state || null; _this.parseHash({ hash: hash, nonce: transactionNonce, state: transactionState }, cb) }) }, WebAuth.prototype.changePassword = function (options, cb) { return this.client.dbConnection.changePassword(options, cb) }, WebAuth.prototype.passwordlessStart = function (options, cb) { return this.client.passwordless.start(options, cb) }, WebAuth.prototype.signup = function (options, cb) { return this.client.dbConnection.signup(options, cb) }, WebAuth.prototype.authorize = function (options) { var params = objectHelper.merge(this.baseOptions, ["clientID", "responseType", "responseMode", "redirectUri", "scope", "audience", "_csrf", "state", "_intstate", "nonce"])["with"](options); assert.check(params, { type: "object", message: "options parameter is not valid" }, { responseType: { type: "string", message: "responseType option is required" } }), params = this.transactionManager.process(params), windowHelper.redirect(this.client.buildAuthorizeUrl(params)) }, WebAuth.prototype.signupAndAuthorize = function (options, cb) { var _this = this; return this.client.dbConnection.signup(objectHelper.blacklist(options, ["popupHandler"]), function (err) { return err ? cb(err) : (options.realm = options.connection, options.username || (options.username = options.email), void _this.client.login(options, cb)) }) }, WebAuth.prototype.login = function (options, cb) { this.crossOriginAuthentication.login(options, cb) }, WebAuth.prototype.passwordlessLogin = function (options, cb) { var loginOptions = objectHelper.extend({ credentialType: "http://auth0.com/oauth/grant-type/passwordless/otp", realm: options.connection, username: options.email || options.phoneNumber, otp: options.verificationCode }, objectHelper.blacklist(options, ["connection", "email", "phoneNumber", "verificationCode"])); this.crossOriginAuthentication.login(loginOptions, cb) }, WebAuth.prototype.crossOriginAuthenticationCallback = function () { this.crossOriginAuthentication.callback() }, WebAuth.prototype.logout = function (options) { windowHelper.redirect(this.client.buildLogoutUrl(options)) }, WebAuth.prototype.passwordlessVerify = function (options, cb) { var _this = this; return this.client.passwordless.verify(options, function (err) { return err ? cb(err) : windowHelper.redirect(_this.client.passwordless.buildVerifyUrl(options)) }) }, module.exports = WebAuth }, function (module, exports, __webpack_require__) { function IdTokenVerifier(parameters) { var options = parameters || {}; if (this.jwksCache = options.jwksCache || new DummyCache, this.expectedAlg = options.expectedAlg || "RS256", this.issuer = options.issuer, this.audience = options.audience, this.leeway = options.leeway || 0, this.__disableExpirationCheck = options.__disableExpirationCheck || !1, this.jwksURI = options.jwksURI, this.leeway < 0 || this.leeway > 60) throw new error.ConfigurationError("The leeway should be positive and lower than a minute."); if (supportedAlgs.indexOf(this.expectedAlg) === -1) throw new error.ConfigurationError("Algorithm " + this.expectedAlg + " is not supported. (Expected algs: [" + supportedAlgs.join(",") + "])") } var sha256 = __webpack_require__(38), cryptoBase64 = __webpack_require__(40), cryptoHex = __webpack_require__(41), RSAVerifier = __webpack_require__(42), base64 = __webpack_require__(44), jwks = __webpack_require__(45), error = __webpack_require__(46), DummyCache = __webpack_require__(47), supportedAlgs = ["RS256"]; IdTokenVerifier.prototype.verify = function (token, nonce, cb) { var jwt = this.decode(token); if (jwt instanceof Error) return cb(jwt, !1); var headAndPayload = jwt.encoded.header + "." + jwt.encoded.payload, signature = base64.decodeToHEX(jwt.encoded.signature), alg = jwt.header.alg, kid = jwt.header.kid, aud = jwt.payload.aud, iss = jwt.payload.iss, exp = jwt.payload.exp, nbf = jwt.payload.nbf, tnonce = jwt.payload.nonce || null; if (this.issuer !== iss) return cb(new error.TokenValidationError("Issuer " + iss + " is not valid."), !1); if (this.audience !== aud) return cb(new error.TokenValidationError("Audience " + aud + " is not valid."), !1); if (this.expectedAlg !== alg) return cb(new error.TokenValidationError("Algorithm " + alg + " is not supported. (Expected algs: [" + supportedAlgs.join(",") + "])"), !1); if (tnonce !== nonce) return cb(new error.TokenValidationError("Nonce does not match."), !1); var expirationError = this.verifyExpAndNbf(exp, nbf); return expirationError ? cb(expirationError, !1) : this.getRsaVerifier(iss, kid, function (err, rsaVerifier) { return err ? cb(err) : rsaVerifier.verify(headAndPayload, signature) ? cb(null, jwt.payload) : cb(new error.TokenValidationError("Invalid signature.")) }) }, IdTokenVerifier.prototype.verifyExpAndNbf = function (exp, nbf) { var now = new Date, expDate = new Date(0), nbfDate = new Date(0); return this.__disableExpirationCheck ? null : (expDate.setUTCSeconds(exp + this.leeway), now > expDate ? new error.TokenValidationError("Expired token.") : "undefined" == typeof nbf ? null : (nbfDate.setUTCSeconds(nbf - this.leeway), now < nbfDate ? new error.TokenValidationError("The token is not valid until later in the future. Please check your computed clock.") : null)) }, IdTokenVerifier.prototype.verifyExpAndIat = function (exp, iat) { var now = new Date, expDate = new Date(0), iatDate = new Date(0); return this.__disableExpirationCheck ? null : (expDate.setUTCSeconds(exp + this.leeway), now > expDate ? new error.TokenValidationError("Expired token.") : (iatDate.setUTCSeconds(iat - this.leeway), now < iatDate ? new error.TokenValidationError("The token was issued in the future. Please check your computed clock.") : null)) }, IdTokenVerifier.prototype.getRsaVerifier = function (iss, kid, cb) { var _this = this, cachekey = iss + kid; if (this.jwksCache.has(cachekey)) { var keyInfo = this.jwksCache.get(cachekey); cb(null, new RSAVerifier(keyInfo.modulus, keyInfo.exp)) } else jwks.getJWKS({ jwksURI: this.jwksURI, iss: iss, kid: kid }, function (err, keyInfo) { return err ? cb(err) : (_this.jwksCache.set(cachekey, keyInfo), cb(null, new RSAVerifier(keyInfo.modulus, keyInfo.exp))) }) }, IdTokenVerifier.prototype.decode = function (token) { var header, payload, parts = token.split("."); if (3 !== parts.length) return new error.TokenValidationError("Cannot decode a malformed JWT"); try { header = JSON.parse(base64.decodeToString(parts[0])), payload = JSON.parse(base64.decodeToString(parts[1])) } catch (e) { return new error.TokenValidationError("Token header or payload is not valid JSON") } return { header: header, payload: payload, encoded: { header: parts[0], payload: parts[1], signature: parts[2] } } }, IdTokenVerifier.prototype.validateAccessToken = function (accessToken, alg, atHash, cb) { if (this.expectedAlg !== alg) return cb(new error.TokenValidationError("Algorithm " + alg + " is not supported. (Expected alg: " + this.expectedAlg + ")")); var sha256AccessToken = sha256(accessToken), hashToHex = cryptoHex.stringify(sha256AccessToken), hashToHexFirstHalf = hashToHex.substring(0, hashToHex.length / 2), hashFirstHalfWordArray = cryptoHex.parse(hashToHexFirstHalf), hashFirstHalfBase64 = cryptoBase64.stringify(hashFirstHalfWordArray), hashFirstHalfBase64SafeUrl = base64.base64ToBase64Url(hashFirstHalfBase64); return cb(hashFirstHalfBase64SafeUrl !== atHash ? new error.TokenValidationError("Invalid access_token") : null) }, module.exports = IdTokenVerifier }, function (module, exports, __webpack_require__) { !function (root, factory) { module.exports = exports = factory(__webpack_require__(39)) }(this, function (CryptoJS) { return function (Math) { var C = CryptoJS, C_lib = C.lib, WordArray = C_lib.WordArray, Hasher = C_lib.Hasher, C_algo = C.algo, H = [], K = []; !function () { function isPrime(n) { for (var sqrtN = Math.sqrt(n), factor = 2; factor <= sqrtN; factor++)if (!(n % factor)) return !1; return !0 } function getFractionalBits(n) { return 4294967296 * (n - (0 | n)) | 0 } for (var n = 2, nPrime = 0; nPrime < 64;)isPrime(n) && (nPrime < 8 && (H[nPrime] = getFractionalBits(Math.pow(n, .5))), K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3)), nPrime++), n++ }(); var W = [], SHA256 = C_algo.SHA256 = Hasher.extend({ _doReset: function () { this._hash = new WordArray.init(H.slice(0)) }, _doProcessBlock: function (M, offset) { for (var H = this._hash.words, a = H[0], b = H[1], c = H[2], d = H[3], e = H[4], f = H[5], g = H[6], h = H[7], i = 0; i < 64; i++) { if (i < 16) W[i] = 0 | M[offset + i]; else { var gamma0x = W[i - 15], gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3, gamma1x = W[i - 2], gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10; W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16] } var ch = e & f ^ ~e & g, maj = a & b ^ a & c ^ b & c, sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22), sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25), t1 = h + sigma1 + ch + K[i] + W[i], t2 = sigma0 + maj; h = g, g = f, f = e, e = d + t1 | 0, d = c, c = b, b = a, a = t1 + t2 | 0 } H[0] = H[0] + a | 0, H[1] = H[1] + b | 0, H[2] = H[2] + c | 0, H[3] = H[3] + d | 0, H[4] = H[4] + e | 0, H[5] = H[5] + f | 0, H[6] = H[6] + g | 0, H[7] = H[7] + h | 0 }, _doFinalize: function () { var data = this._data, dataWords = data.words, nBitsTotal = 8 * this._nDataBytes, nBitsLeft = 8 * data.sigBytes; return dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32, dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296), dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal, data.sigBytes = 4 * dataWords.length, this._process(), this._hash }, clone: function () { var clone = Hasher.clone.call(this); return clone._hash = this._hash.clone(), clone } }); C.SHA256 = Hasher._createHelper(SHA256), C.HmacSHA256 = Hasher._createHmacHelper(SHA256) }(Math), CryptoJS.SHA256 }) }, function (module, exports, __webpack_require__) {
  !function (root, factory) { module.exports = exports = factory() }(this, function () {
    var CryptoJS = CryptoJS || function (Math, undefined) {
      var create = Object.create || function () { function F() { } return function (obj) { var subtype; return F.prototype = obj, subtype = new F, F.prototype = null, subtype } }(), C = {}, C_lib = C.lib = {}, Base = C_lib.Base = function () { return { extend: function (overrides) { var subtype = create(this); return overrides && subtype.mixIn(overrides), subtype.hasOwnProperty("init") && this.init !== subtype.init || (subtype.init = function () { subtype.$super.init.apply(this, arguments) }), subtype.init.prototype = subtype, subtype.$super = this, subtype }, create: function () { var instance = this.extend(); return instance.init.apply(instance, arguments), instance }, init: function () { }, mixIn: function (properties) { for (var propertyName in properties) properties.hasOwnProperty(propertyName) && (this[propertyName] = properties[propertyName]); properties.hasOwnProperty("toString") && (this.toString = properties.toString) }, clone: function () { return this.init.prototype.extend(this) } } }(), WordArray = C_lib.WordArray = Base.extend({
        init: function (words, sigBytes) { words = this.words = words || [], sigBytes != undefined ? this.sigBytes = sigBytes : this.sigBytes = 4 * words.length }, toString: function (encoder) { return (encoder || Hex).stringify(this) }, concat: function (wordArray) {
          var thisWords = this.words, thatWords = wordArray.words, thisSigBytes = this.sigBytes, thatSigBytes = wordArray.sigBytes; if (this.clamp(), thisSigBytes % 4) for (var i = 0; i < thatSigBytes; i++) { var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255; thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8 } else for (var i = 0; i < thatSigBytes; i += 4)thisWords[thisSigBytes + i >>> 2] = thatWords[i >>> 2]; return this.sigBytes += thatSigBytes, this
        }, clamp: function () { var words = this.words, sigBytes = this.sigBytes; words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8, words.length = Math.ceil(sigBytes / 4) }, clone: function () { var clone = Base.clone.call(this); return clone.words = this.words.slice(0), clone }, random: function (nBytes) { for (var rcache, words = [], r = function (m_w) { var m_w = m_w, m_z = 987654321, mask = 4294967295; return function () { m_z = 36969 * (65535 & m_z) + (m_z >> 16) & mask, m_w = 18e3 * (65535 & m_w) + (m_w >> 16) & mask; var result = (m_z << 16) + m_w & mask; return result /= 4294967296, result += .5, result * (Math.random() > .5 ? 1 : -1) } }, i = 0; i < nBytes; i += 4) { var _r = r(4294967296 * (rcache || Math.random())); rcache = 987654071 * _r(), words.push(4294967296 * _r() | 0) } return new WordArray.init(words, nBytes) }
      }), C_enc = C.enc = {}, Hex = C_enc.Hex = { stringify: function (wordArray) { for (var words = wordArray.words, sigBytes = wordArray.sigBytes, hexChars = [], i = 0; i < sigBytes; i++) { var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255; hexChars.push((bite >>> 4).toString(16)), hexChars.push((15 & bite).toString(16)) } return hexChars.join("") }, parse: function (hexStr) { for (var hexStrLength = hexStr.length, words = [], i = 0; i < hexStrLength; i += 2)words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4; return new WordArray.init(words, hexStrLength / 2) } }, Latin1 = C_enc.Latin1 = { stringify: function (wordArray) { for (var words = wordArray.words, sigBytes = wordArray.sigBytes, latin1Chars = [], i = 0; i < sigBytes; i++) { var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255; latin1Chars.push(String.fromCharCode(bite)) } return latin1Chars.join("") }, parse: function (latin1Str) { for (var latin1StrLength = latin1Str.length, words = [], i = 0; i < latin1StrLength; i++)words[i >>> 2] |= (255 & latin1Str.charCodeAt(i)) << 24 - i % 4 * 8; return new WordArray.init(words, latin1StrLength) } }, Utf8 = C_enc.Utf8 = { stringify: function (wordArray) { try { return decodeURIComponent(escape(Latin1.stringify(wordArray))) } catch (e) { throw new Error("Malformed UTF-8 data") } }, parse: function (utf8Str) { return Latin1.parse(unescape(encodeURIComponent(utf8Str))) } }, BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({ reset: function () { this._data = new WordArray.init, this._nDataBytes = 0 }, _append: function (data) { "string" == typeof data && (data = Utf8.parse(data)), this._data.concat(data), this._nDataBytes += data.sigBytes }, _process: function (doFlush) { var data = this._data, dataWords = data.words, dataSigBytes = data.sigBytes, blockSize = this.blockSize, blockSizeBytes = 4 * blockSize, nBlocksReady = dataSigBytes / blockSizeBytes; nBlocksReady = doFlush ? Math.ceil(nBlocksReady) : Math.max((0 | nBlocksReady) - this._minBufferSize, 0); var nWordsReady = nBlocksReady * blockSize, nBytesReady = Math.min(4 * nWordsReady, dataSigBytes); if (nWordsReady) { for (var offset = 0; offset < nWordsReady; offset += blockSize)this._doProcessBlock(dataWords, offset); var processedWords = dataWords.splice(0, nWordsReady); data.sigBytes -= nBytesReady } return new WordArray.init(processedWords, nBytesReady) }, clone: function () { var clone = Base.clone.call(this); return clone._data = this._data.clone(), clone }, _minBufferSize: 0 }), C_algo = (C_lib.Hasher = BufferedBlockAlgorithm.extend({ cfg: Base.extend(), init: function (cfg) { this.cfg = this.cfg.extend(cfg), this.reset() }, reset: function () { BufferedBlockAlgorithm.reset.call(this), this._doReset() }, update: function (messageUpdate) { return this._append(messageUpdate), this._process(), this }, finalize: function (messageUpdate) { messageUpdate && this._append(messageUpdate); var hash = this._doFinalize(); return hash }, blockSize: 16, _createHelper: function (hasher) { return function (message, cfg) { return new hasher.init(cfg).finalize(message) } }, _createHmacHelper: function (hasher) { return function (message, key) { return new C_algo.HMAC.init(hasher, key).finalize(message) } } }), C.algo = {}); return C
    }(Math); return CryptoJS
  })
}, function (module, exports, __webpack_require__) { !function (root, factory) { module.exports = exports = factory(__webpack_require__(39)) }(this, function (CryptoJS) { return function () { function parseLoop(base64Str, base64StrLength, reverseMap) { for (var words = [], nBytes = 0, i = 0; i < base64StrLength; i++)if (i % 4) { var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2, bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2; words[nBytes >>> 2] |= (bits1 | bits2) << 24 - nBytes % 4 * 8, nBytes++ } return WordArray.create(words, nBytes) } var C = CryptoJS, C_lib = C.lib, WordArray = C_lib.WordArray, C_enc = C.enc; C_enc.Base64 = { stringify: function (wordArray) { var words = wordArray.words, sigBytes = wordArray.sigBytes, map = this._map; wordArray.clamp(); for (var base64Chars = [], i = 0; i < sigBytes; i += 3)for (var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255, byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255, byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255, triplet = byte1 << 16 | byte2 << 8 | byte3, j = 0; j < 4 && i + .75 * j < sigBytes; j++)base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63)); var paddingChar = map.charAt(64); if (paddingChar) for (; base64Chars.length % 4;)base64Chars.push(paddingChar); return base64Chars.join("") }, parse: function (base64Str) { var base64StrLength = base64Str.length, map = this._map, reverseMap = this._reverseMap; if (!reverseMap) { reverseMap = this._reverseMap = []; for (var j = 0; j < map.length; j++)reverseMap[map.charCodeAt(j)] = j } var paddingChar = map.charAt(64); if (paddingChar) { var paddingIndex = base64Str.indexOf(paddingChar); paddingIndex !== -1 && (base64StrLength = paddingIndex) } return parseLoop(base64Str, base64StrLength, reverseMap) }, _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=" } }(), CryptoJS.enc.Base64 }) }, function (module, exports, __webpack_require__) { !function (root, factory) { module.exports = exports = factory(__webpack_require__(39)) }(this, function (CryptoJS) { return CryptoJS.enc.Hex }) }, function (module, exports, __webpack_require__) { function RSAVerifier(modulus, exp) { if (this.n = null, this.e = 0, !(null != modulus && null != exp && modulus.length > 0 && exp.length > 0)) throw new Error("Invalid key data"); this.n = new BigInteger(modulus, 16), this.e = parseInt(exp, 16) } function getAlgorithmFromDigest(hDigestInfo) { for (var algName in DigestInfoHead) { var head = DigestInfoHead[algName], len = head.length; if (hDigestInfo.substring(0, len) === head) return { alg: algName, hash: hDigestInfo.substring(len) } } return [] } var BigInteger = __webpack_require__(43).BigInteger, SHA256 = __webpack_require__(38), DigestInfoHead = { sha1: "3021300906052b0e03021a05000414", sha224: "302d300d06096086480165030402040500041c", sha256: "3031300d060960864801650304020105000420", sha384: "3041300d060960864801650304020205000430", sha512: "3051300d060960864801650304020305000440", md2: "3020300c06082a864886f70d020205000410", md5: "3020300c06082a864886f70d020505000410", ripemd160: "3021300906052b2403020105000414" }, DigestAlgs = { sha256: SHA256 }; RSAVerifier.prototype.verify = function (msg, encsig) { encsig = encsig.replace(/[^0-9a-f]|[\s\n]]/gi, ""); var sig = new BigInteger(encsig, 16); if (sig.bitLength() > this.n.bitLength()) throw new Error("Signature does not match with the key modulus."); var decryptedSig = sig.modPowInt(this.e, this.n), digest = decryptedSig.toString(16).replace(/^1f+00/, ""), digestInfo = getAlgorithmFromDigest(digest); if (0 === digestInfo.length) return !1; if (!DigestAlgs.hasOwnProperty(digestInfo.alg)) throw new Error("Hashing algorithm is not supported."); var msgHash = DigestAlgs[digestInfo.alg](msg).toString(); return digestInfo.hash === msgHash }, module.exports = RSAVerifier }, function (module, exports, __webpack_require__) { (function () { function BigInteger(a, b, c) { null != a && ("number" == typeof a ? this.fromNumber(a, b, c) : null == b && "string" != typeof a ? this.fromString(a, 256) : this.fromString(a, b)) } function nbi() { return new BigInteger(null) } function am1(i, x, w, j, c, n) { for (; --n >= 0;) { var v = x * this[i++] + w[j] + c; c = Math.floor(v / 67108864), w[j++] = 67108863 & v } return c } function am2(i, x, w, j, c, n) { for (var xl = 32767 & x, xh = x >> 15; --n >= 0;) { var l = 32767 & this[i], h = this[i++] >> 15, m = xh * l + h * xl; l = xl * l + ((32767 & m) << 15) + w[j] + (1073741823 & c), c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30), w[j++] = 1073741823 & l } return c } function am3(i, x, w, j, c, n) { for (var xl = 16383 & x, xh = x >> 14; --n >= 0;) { var l = 16383 & this[i], h = this[i++] >> 14, m = xh * l + h * xl; l = xl * l + ((16383 & m) << 14) + w[j] + c, c = (l >> 28) + (m >> 14) + xh * h, w[j++] = 268435455 & l } return c } function int2char(n) { return BI_RM.charAt(n) } function intAt(s, i) { var c = BI_RC[s.charCodeAt(i)]; return null == c ? -1 : c } function bnpCopyTo(r) { for (var i = this.t - 1; i >= 0; --i)r[i] = this[i]; r.t = this.t, r.s = this.s } function bnpFromInt(x) { this.t = 1, this.s = x < 0 ? -1 : 0, x > 0 ? this[0] = x : x < -1 ? this[0] = x + this.DV : this.t = 0 } function nbv(i) { var r = nbi(); return r.fromInt(i), r } function bnpFromString(s, b) { var k; if (16 == b) k = 4; else if (8 == b) k = 3; else if (256 == b) k = 8; else if (2 == b) k = 1; else if (32 == b) k = 5; else { if (4 != b) return void this.fromRadix(s, b); k = 2 } this.t = 0, this.s = 0; for (var i = s.length, mi = !1, sh = 0; --i >= 0;) { var x = 8 == k ? 255 & s[i] : intAt(s, i); x < 0 ? "-" == s.charAt(i) && (mi = !0) : (mi = !1, 0 == sh ? this[this.t++] = x : sh + k > this.DB ? (this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh, this[this.t++] = x >> this.DB - sh) : this[this.t - 1] |= x << sh, sh += k, sh >= this.DB && (sh -= this.DB)) } 8 == k && 0 != (128 & s[0]) && (this.s = -1, sh > 0 && (this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh)), this.clamp(), mi && BigInteger.ZERO.subTo(this, this) } function bnpClamp() { for (var c = this.s & this.DM; this.t > 0 && this[this.t - 1] == c;)--this.t } function bnToString(b) { if (this.s < 0) return "-" + this.negate().toString(b); var k; if (16 == b) k = 4; else if (8 == b) k = 3; else if (2 == b) k = 1; else if (32 == b) k = 5; else { if (4 != b) return this.toRadix(b); k = 2 } var d, km = (1 << k) - 1, m = !1, r = "", i = this.t, p = this.DB - i * this.DB % k; if (i-- > 0) for (p < this.DB && (d = this[i] >> p) > 0 && (m = !0, r = int2char(d)); i >= 0;)p < k ? (d = (this[i] & (1 << p) - 1) << k - p, d |= this[--i] >> (p += this.DB - k)) : (d = this[i] >> (p -= k) & km, p <= 0 && (p += this.DB, --i)), d > 0 && (m = !0), m && (r += int2char(d)); return m ? r : "0" } function bnNegate() { var r = nbi(); return BigInteger.ZERO.subTo(this, r), r } function bnAbs() { return this.s < 0 ? this.negate() : this } function bnCompareTo(a) { var r = this.s - a.s; if (0 != r) return r; var i = this.t; if (r = i - a.t, 0 != r) return this.s < 0 ? -r : r; for (; --i >= 0;)if (0 != (r = this[i] - a[i])) return r; return 0 } function nbits(x) { var t, r = 1; return 0 != (t = x >>> 16) && (x = t, r += 16), 0 != (t = x >> 8) && (x = t, r += 8), 0 != (t = x >> 4) && (x = t, r += 4), 0 != (t = x >> 2) && (x = t, r += 2), 0 != (t = x >> 1) && (x = t, r += 1), r } function bnBitLength() { return this.t <= 0 ? 0 : this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM) } function bnpDLShiftTo(n, r) { var i; for (i = this.t - 1; i >= 0; --i)r[i + n] = this[i]; for (i = n - 1; i >= 0; --i)r[i] = 0; r.t = this.t + n, r.s = this.s } function bnpDRShiftTo(n, r) { for (var i = n; i < this.t; ++i)r[i - n] = this[i]; r.t = Math.max(this.t - n, 0), r.s = this.s } function bnpLShiftTo(n, r) { var i, bs = n % this.DB, cbs = this.DB - bs, bm = (1 << cbs) - 1, ds = Math.floor(n / this.DB), c = this.s << bs & this.DM; for (i = this.t - 1; i >= 0; --i)r[i + ds + 1] = this[i] >> cbs | c, c = (this[i] & bm) << bs; for (i = ds - 1; i >= 0; --i)r[i] = 0; r[ds] = c, r.t = this.t + ds + 1, r.s = this.s, r.clamp() } function bnpRShiftTo(n, r) { r.s = this.s; var ds = Math.floor(n / this.DB); if (ds >= this.t) return void (r.t = 0); var bs = n % this.DB, cbs = this.DB - bs, bm = (1 << bs) - 1; r[0] = this[ds] >> bs; for (var i = ds + 1; i < this.t; ++i)r[i - ds - 1] |= (this[i] & bm) << cbs, r[i - ds] = this[i] >> bs; bs > 0 && (r[this.t - ds - 1] |= (this.s & bm) << cbs), r.t = this.t - ds, r.clamp() } function bnpSubTo(a, r) { for (var i = 0, c = 0, m = Math.min(a.t, this.t); i < m;)c += this[i] - a[i], r[i++] = c & this.DM, c >>= this.DB; if (a.t < this.t) { for (c -= a.s; i < this.t;)c += this[i], r[i++] = c & this.DM, c >>= this.DB; c += this.s } else { for (c += this.s; i < a.t;)c -= a[i], r[i++] = c & this.DM, c >>= this.DB; c -= a.s } r.s = c < 0 ? -1 : 0, c < -1 ? r[i++] = this.DV + c : c > 0 && (r[i++] = c), r.t = i, r.clamp() } function bnpMultiplyTo(a, r) { var x = this.abs(), y = a.abs(), i = x.t; for (r.t = i + y.t; --i >= 0;)r[i] = 0; for (i = 0; i < y.t; ++i)r[i + x.t] = x.am(0, y[i], r, i, 0, x.t); r.s = 0, r.clamp(), this.s != a.s && BigInteger.ZERO.subTo(r, r) } function bnpSquareTo(r) { for (var x = this.abs(), i = r.t = 2 * x.t; --i >= 0;)r[i] = 0; for (i = 0; i < x.t - 1; ++i) { var c = x.am(i, x[i], r, 2 * i, 0, 1); (r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV && (r[i + x.t] -= x.DV, r[i + x.t + 1] = 1) } r.t > 0 && (r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1)), r.s = 0, r.clamp() } function bnpDivRemTo(m, q, r) { var pm = m.abs(); if (!(pm.t <= 0)) { var pt = this.abs(); if (pt.t < pm.t) return null != q && q.fromInt(0), void (null != r && this.copyTo(r)); null == r && (r = nbi()); var y = nbi(), ts = this.s, ms = m.s, nsh = this.DB - nbits(pm[pm.t - 1]); nsh > 0 ? (pm.lShiftTo(nsh, y), pt.lShiftTo(nsh, r)) : (pm.copyTo(y), pt.copyTo(r)); var ys = y.t, y0 = y[ys - 1]; if (0 != y0) { var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0), d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2, i = r.t, j = i - ys, t = null == q ? nbi() : q; for (y.dlShiftTo(j, t), r.compareTo(t) >= 0 && (r[r.t++] = 1, r.subTo(t, r)), BigInteger.ONE.dlShiftTo(ys, t), t.subTo(y, y); y.t < ys;)y[y.t++] = 0; for (; --j >= 0;) { var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2); if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) for (y.dlShiftTo(j, t), r.subTo(t, r); r[i] < --qd;)r.subTo(t, r) } null != q && (r.drShiftTo(ys, q), ts != ms && BigInteger.ZERO.subTo(q, q)), r.t = ys, r.clamp(), nsh > 0 && r.rShiftTo(nsh, r), ts < 0 && BigInteger.ZERO.subTo(r, r) } } } function bnMod(a) { var r = nbi(); return this.abs().divRemTo(a, null, r), this.s < 0 && r.compareTo(BigInteger.ZERO) > 0 && a.subTo(r, r), r } function Classic(m) { this.m = m } function cConvert(x) { return x.s < 0 || x.compareTo(this.m) >= 0 ? x.mod(this.m) : x } function cRevert(x) { return x } function cReduce(x) { x.divRemTo(this.m, null, x) } function cMulTo(x, y, r) { x.multiplyTo(y, r), this.reduce(r) } function cSqrTo(x, r) { x.squareTo(r), this.reduce(r) } function bnpInvDigit() { if (this.t < 1) return 0; var x = this[0]; if (0 == (1 & x)) return 0; var y = 3 & x; return y = y * (2 - (15 & x) * y) & 15, y = y * (2 - (255 & x) * y) & 255, y = y * (2 - ((65535 & x) * y & 65535)) & 65535, y = y * (2 - x * y % this.DV) % this.DV, y > 0 ? this.DV - y : -y } function Montgomery(m) { this.m = m, this.mp = m.invDigit(), this.mpl = 32767 & this.mp, this.mph = this.mp >> 15, this.um = (1 << m.DB - 15) - 1, this.mt2 = 2 * m.t } function montConvert(x) { var r = nbi(); return x.abs().dlShiftTo(this.m.t, r), r.divRemTo(this.m, null, r), x.s < 0 && r.compareTo(BigInteger.ZERO) > 0 && this.m.subTo(r, r), r } function montRevert(x) { var r = nbi(); return x.copyTo(r), this.reduce(r), r } function montReduce(x) { for (; x.t <= this.mt2;)x[x.t++] = 0; for (var i = 0; i < this.m.t; ++i) { var j = 32767 & x[i], u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM; for (j = i + this.m.t, x[j] += this.m.am(0, u0, x, i, 0, this.m.t); x[j] >= x.DV;)x[j] -= x.DV, x[++j]++ } x.clamp(), x.drShiftTo(this.m.t, x), x.compareTo(this.m) >= 0 && x.subTo(this.m, x) } function montSqrTo(x, r) { x.squareTo(r), this.reduce(r) } function montMulTo(x, y, r) { x.multiplyTo(y, r), this.reduce(r) } function bnpIsEven() { return 0 == (this.t > 0 ? 1 & this[0] : this.s) } function bnpExp(e, z) { if (e > 4294967295 || e < 1) return BigInteger.ONE; var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1; for (g.copyTo(r); --i >= 0;)if (z.sqrTo(r, r2), (e & 1 << i) > 0) z.mulTo(r2, g, r); else { var t = r; r = r2, r2 = t } return z.revert(r) } function bnModPowInt(e, m) { var z; return z = e < 256 || m.isEven() ? new Classic(m) : new Montgomery(m), this.exp(e, z) } function bnClone() { var r = nbi(); return this.copyTo(r), r } function bnIntValue() { if (this.s < 0) { if (1 == this.t) return this[0] - this.DV; if (0 == this.t) return -1 } else { if (1 == this.t) return this[0]; if (0 == this.t) return 0 } return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0] } function bnByteValue() { return 0 == this.t ? this.s : this[0] << 24 >> 24 } function bnShortValue() { return 0 == this.t ? this.s : this[0] << 16 >> 16 } function bnpChunkSize(r) { return Math.floor(Math.LN2 * this.DB / Math.log(r)) } function bnSigNum() { return this.s < 0 ? -1 : this.t <= 0 || 1 == this.t && this[0] <= 0 ? 0 : 1 } function bnpToRadix(b) { if (null == b && (b = 10), 0 == this.signum() || b < 2 || b > 36) return "0"; var cs = this.chunkSize(b), a = Math.pow(b, cs), d = nbv(a), y = nbi(), z = nbi(), r = ""; for (this.divRemTo(d, y, z); y.signum() > 0;)r = (a + z.intValue()).toString(b).substr(1) + r, y.divRemTo(d, y, z); return z.intValue().toString(b) + r } function bnpFromRadix(s, b) { this.fromInt(0), null == b && (b = 10); for (var cs = this.chunkSize(b), d = Math.pow(b, cs), mi = !1, j = 0, w = 0, i = 0; i < s.length; ++i) { var x = intAt(s, i); x < 0 ? "-" == s.charAt(i) && 0 == this.signum() && (mi = !0) : (w = b * w + x, ++j >= cs && (this.dMultiply(d), this.dAddOffset(w, 0), j = 0, w = 0)) } j > 0 && (this.dMultiply(Math.pow(b, j)), this.dAddOffset(w, 0)), mi && BigInteger.ZERO.subTo(this, this) } function bnpFromNumber(a, b, c) { if ("number" == typeof b) if (a < 2) this.fromInt(1); else for (this.fromNumber(a, c), this.testBit(a - 1) || this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(b);)this.dAddOffset(2, 0), this.bitLength() > a && this.subTo(BigInteger.ONE.shiftLeft(a - 1), this); else { var x = new Array, t = 7 & a; x.length = (a >> 3) + 1, b.nextBytes(x), t > 0 ? x[0] &= (1 << t) - 1 : x[0] = 0, this.fromString(x, 256) } } function bnToByteArray() { var i = this.t, r = new Array; r[0] = this.s; var d, p = this.DB - i * this.DB % 8, k = 0; if (i-- > 0) for (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p && (r[k++] = d | this.s << this.DB - p); i >= 0;)p < 8 ? (d = (this[i] & (1 << p) - 1) << 8 - p, d |= this[--i] >> (p += this.DB - 8)) : (d = this[i] >> (p -= 8) & 255, p <= 0 && (p += this.DB, --i)), 0 != (128 & d) && (d |= -256), 0 == k && (128 & this.s) != (128 & d) && ++k, (k > 0 || d != this.s) && (r[k++] = d); return r } function bnEquals(a) { return 0 == this.compareTo(a) } function bnMin(a) { return this.compareTo(a) < 0 ? this : a } function bnMax(a) { return this.compareTo(a) > 0 ? this : a } function bnpBitwiseTo(a, op, r) { var i, f, m = Math.min(a.t, this.t); for (i = 0; i < m; ++i)r[i] = op(this[i], a[i]); if (a.t < this.t) { for (f = a.s & this.DM, i = m; i < this.t; ++i)r[i] = op(this[i], f); r.t = this.t } else { for (f = this.s & this.DM, i = m; i < a.t; ++i)r[i] = op(f, a[i]); r.t = a.t } r.s = op(this.s, a.s), r.clamp() } function op_and(x, y) { return x & y } function bnAnd(a) { var r = nbi(); return this.bitwiseTo(a, op_and, r), r } function op_or(x, y) { return x | y } function bnOr(a) { var r = nbi(); return this.bitwiseTo(a, op_or, r), r } function op_xor(x, y) { return x ^ y } function bnXor(a) { var r = nbi(); return this.bitwiseTo(a, op_xor, r), r } function op_andnot(x, y) { return x & ~y } function bnAndNot(a) { var r = nbi(); return this.bitwiseTo(a, op_andnot, r), r } function bnNot() { for (var r = nbi(), i = 0; i < this.t; ++i)r[i] = this.DM & ~this[i]; return r.t = this.t, r.s = ~this.s, r } function bnShiftLeft(n) { var r = nbi(); return n < 0 ? this.rShiftTo(-n, r) : this.lShiftTo(n, r), r } function bnShiftRight(n) { var r = nbi(); return n < 0 ? this.lShiftTo(-n, r) : this.rShiftTo(n, r), r } function lbit(x) { if (0 == x) return -1; var r = 0; return 0 == (65535 & x) && (x >>= 16, r += 16), 0 == (255 & x) && (x >>= 8, r += 8), 0 == (15 & x) && (x >>= 4, r += 4), 0 == (3 & x) && (x >>= 2, r += 2), 0 == (1 & x) && ++r, r } function bnGetLowestSetBit() { for (var i = 0; i < this.t; ++i)if (0 != this[i]) return i * this.DB + lbit(this[i]); return this.s < 0 ? this.t * this.DB : -1 } function cbit(x) { for (var r = 0; 0 != x;)x &= x - 1, ++r; return r } function bnBitCount() { for (var r = 0, x = this.s & this.DM, i = 0; i < this.t; ++i)r += cbit(this[i] ^ x); return r } function bnTestBit(n) { var j = Math.floor(n / this.DB); return j >= this.t ? 0 != this.s : 0 != (this[j] & 1 << n % this.DB) } function bnpChangeBit(n, op) { var r = BigInteger.ONE.shiftLeft(n); return this.bitwiseTo(r, op, r), r } function bnSetBit(n) { return this.changeBit(n, op_or) } function bnClearBit(n) { return this.changeBit(n, op_andnot) } function bnFlipBit(n) { return this.changeBit(n, op_xor) } function bnpAddTo(a, r) { for (var i = 0, c = 0, m = Math.min(a.t, this.t); i < m;)c += this[i] + a[i], r[i++] = c & this.DM, c >>= this.DB; if (a.t < this.t) { for (c += a.s; i < this.t;)c += this[i], r[i++] = c & this.DM, c >>= this.DB; c += this.s } else { for (c += this.s; i < a.t;)c += a[i], r[i++] = c & this.DM, c >>= this.DB; c += a.s } r.s = c < 0 ? -1 : 0, c > 0 ? r[i++] = c : c < -1 && (r[i++] = this.DV + c), r.t = i, r.clamp() } function bnAdd(a) { var r = nbi(); return this.addTo(a, r), r } function bnSubtract(a) { var r = nbi(); return this.subTo(a, r), r } function bnMultiply(a) { var r = nbi(); return this.multiplyTo(a, r), r } function bnSquare() { var r = nbi(); return this.squareTo(r), r } function bnDivide(a) { var r = nbi(); return this.divRemTo(a, r, null), r } function bnRemainder(a) { var r = nbi(); return this.divRemTo(a, null, r), r } function bnDivideAndRemainder(a) { var q = nbi(), r = nbi(); return this.divRemTo(a, q, r), new Array(q, r) } function bnpDMultiply(n) { this[this.t] = this.am(0, n - 1, this, 0, 0, this.t), ++this.t, this.clamp() } function bnpDAddOffset(n, w) { if (0 != n) { for (; this.t <= w;)this[this.t++] = 0; for (this[w] += n; this[w] >= this.DV;)this[w] -= this.DV, ++w >= this.t && (this[this.t++] = 0), ++this[w] } } function NullExp() { } function nNop(x) { return x } function nMulTo(x, y, r) { x.multiplyTo(y, r) } function nSqrTo(x, r) { x.squareTo(r) } function bnPow(e) { return this.exp(e, new NullExp) } function bnpMultiplyLowerTo(a, n, r) { var i = Math.min(this.t + a.t, n); for (r.s = 0, r.t = i; i > 0;)r[--i] = 0; var j; for (j = r.t - this.t; i < j; ++i)r[i + this.t] = this.am(0, a[i], r, i, 0, this.t); for (j = Math.min(a.t, n); i < j; ++i)this.am(0, a[i], r, i, 0, n - i); r.clamp() } function bnpMultiplyUpperTo(a, n, r) { --n; var i = r.t = this.t + a.t - n; for (r.s = 0; --i >= 0;)r[i] = 0; for (i = Math.max(n - this.t, 0); i < a.t; ++i)r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n); r.clamp(), r.drShiftTo(1, r) } function Barrett(m) { this.r2 = nbi(), this.q3 = nbi(), BigInteger.ONE.dlShiftTo(2 * m.t, this.r2), this.mu = this.r2.divide(m), this.m = m } function barrettConvert(x) { if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m); if (x.compareTo(this.m) < 0) return x; var r = nbi(); return x.copyTo(r), this.reduce(r), r } function barrettRevert(x) { return x } function barrettReduce(x) { for (x.drShiftTo(this.m.t - 1, this.r2), x.t > this.m.t + 1 && (x.t = this.m.t + 1, x.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); x.compareTo(this.r2) < 0;)x.dAddOffset(1, this.m.t + 1); for (x.subTo(this.r2, x); x.compareTo(this.m) >= 0;)x.subTo(this.m, x) } function barrettSqrTo(x, r) { x.squareTo(r), this.reduce(r) } function barrettMulTo(x, y, r) { x.multiplyTo(y, r), this.reduce(r) } function bnModPow(e, m) { var k, z, i = e.bitLength(), r = nbv(1); if (i <= 0) return r; k = i < 18 ? 1 : i < 48 ? 3 : i < 144 ? 4 : i < 768 ? 5 : 6, z = i < 8 ? new Classic(m) : m.isEven() ? new Barrett(m) : new Montgomery(m); var g = new Array, n = 3, k1 = k - 1, km = (1 << k) - 1; if (g[1] = z.convert(this), k > 1) { var g2 = nbi(); for (z.sqrTo(g[1], g2); n <= km;)g[n] = nbi(), z.mulTo(g2, g[n - 2], g[n]), n += 2 } var w, t, j = e.t - 1, is1 = !0, r2 = nbi(); for (i = nbits(e[j]) - 1; j >= 0;) { for (i >= k1 ? w = e[j] >> i - k1 & km : (w = (e[j] & (1 << i + 1) - 1) << k1 - i, j > 0 && (w |= e[j - 1] >> this.DB + i - k1)), n = k; 0 == (1 & w);)w >>= 1, --n; if ((i -= n) < 0 && (i += this.DB, --j), is1) g[w].copyTo(r), is1 = !1; else { for (; n > 1;)z.sqrTo(r, r2), z.sqrTo(r2, r), n -= 2; n > 0 ? z.sqrTo(r, r2) : (t = r, r = r2, r2 = t), z.mulTo(r2, g[w], r) } for (; j >= 0 && 0 == (e[j] & 1 << i);)z.sqrTo(r, r2), t = r, r = r2, r2 = t, --i < 0 && (i = this.DB - 1, --j) } return z.revert(r) } function bnGCD(a) { var x = this.s < 0 ? this.negate() : this.clone(), y = a.s < 0 ? a.negate() : a.clone(); if (x.compareTo(y) < 0) { var t = x; x = y, y = t } var i = x.getLowestSetBit(), g = y.getLowestSetBit(); if (g < 0) return x; for (i < g && (g = i), g > 0 && (x.rShiftTo(g, x), y.rShiftTo(g, y)); x.signum() > 0;)(i = x.getLowestSetBit()) > 0 && x.rShiftTo(i, x), (i = y.getLowestSetBit()) > 0 && y.rShiftTo(i, y), x.compareTo(y) >= 0 ? (x.subTo(y, x), x.rShiftTo(1, x)) : (y.subTo(x, y), y.rShiftTo(1, y)); return g > 0 && y.lShiftTo(g, y), y } function bnpModInt(n) { if (n <= 0) return 0; var d = this.DV % n, r = this.s < 0 ? n - 1 : 0; if (this.t > 0) if (0 == d) r = this[0] % n; else for (var i = this.t - 1; i >= 0; --i)r = (d * r + this[i]) % n; return r } function bnModInverse(m) { var ac = m.isEven(); if (this.isEven() && ac || 0 == m.signum()) return BigInteger.ZERO; for (var u = m.clone(), v = this.clone(), a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1); 0 != u.signum();) { for (; u.isEven();)u.rShiftTo(1, u), ac ? (a.isEven() && b.isEven() || (a.addTo(this, a), b.subTo(m, b)), a.rShiftTo(1, a)) : b.isEven() || b.subTo(m, b), b.rShiftTo(1, b); for (; v.isEven();)v.rShiftTo(1, v), ac ? (c.isEven() && d.isEven() || (c.addTo(this, c), d.subTo(m, d)), c.rShiftTo(1, c)) : d.isEven() || d.subTo(m, d), d.rShiftTo(1, d); u.compareTo(v) >= 0 ? (u.subTo(v, u), ac && a.subTo(c, a), b.subTo(d, b)) : (v.subTo(u, v), ac && c.subTo(a, c), d.subTo(b, d)) } return 0 != v.compareTo(BigInteger.ONE) ? BigInteger.ZERO : d.compareTo(m) >= 0 ? d.subtract(m) : d.signum() < 0 ? (d.addTo(m, d), d.signum() < 0 ? d.add(m) : d) : d } function bnIsProbablePrime(t) { var i, x = this.abs(); if (1 == x.t && x[0] <= lowprimes[lowprimes.length - 1]) { for (i = 0; i < lowprimes.length; ++i)if (x[0] == lowprimes[i]) return !0; return !1 } if (x.isEven()) return !1; for (i = 1; i < lowprimes.length;) { for (var m = lowprimes[i], j = i + 1; j < lowprimes.length && m < lplim;)m *= lowprimes[j++]; for (m = x.modInt(m); i < j;)if (m % lowprimes[i++] == 0) return !1 } return x.millerRabin(t) } function bnpMillerRabin(t) { var n1 = this.subtract(BigInteger.ONE), k = n1.getLowestSetBit(); if (k <= 0) return !1; var r = n1.shiftRight(k); t = t + 1 >> 1, t > lowprimes.length && (t = lowprimes.length); for (var a = nbi(), i = 0; i < t; ++i) { a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]); var y = a.modPow(r, this); if (0 != y.compareTo(BigInteger.ONE) && 0 != y.compareTo(n1)) { for (var j = 1; j++ < k && 0 != y.compareTo(n1);)if (y = y.modPowInt(2, this), 0 == y.compareTo(BigInteger.ONE)) return !1; if (0 != y.compareTo(n1)) return !1 } } return !0 } function rng_seed_int(x) { rng_pool[rng_pptr++] ^= 255 & x, rng_pool[rng_pptr++] ^= x >> 8 & 255, rng_pool[rng_pptr++] ^= x >> 16 & 255, rng_pool[rng_pptr++] ^= x >> 24 & 255, rng_pptr >= rng_psize && (rng_pptr -= rng_psize) } function rng_seed_time() { rng_seed_int((new Date).getTime()) } function rng_get_byte() { if (null == rng_state) { for (rng_seed_time(), rng_state = prng_newstate(), rng_state.init(rng_pool), rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)rng_pool[rng_pptr] = 0; rng_pptr = 0 } return rng_state.next() } function rng_get_bytes(ba) { var i; for (i = 0; i < ba.length; ++i)ba[i] = rng_get_byte() } function SecureRandom() { } function Arcfour() { this.i = 0, this.j = 0, this.S = new Array } function ARC4init(key) { var i, j, t; for (i = 0; i < 256; ++i)this.S[i] = i; for (j = 0, i = 0; i < 256; ++i)j = j + this.S[i] + key[i % key.length] & 255, t = this.S[i], this.S[i] = this.S[j], this.S[j] = t; this.i = 0, this.j = 0 } function ARC4next() { var t; return this.i = this.i + 1 & 255, this.j = this.j + this.S[this.i] & 255, t = this.S[this.i], this.S[this.i] = this.S[this.j], this.S[this.j] = t, this.S[t + this.S[this.i] & 255] } function prng_newstate() { return new Arcfour } var dbits, canary = 0xdeadbeefcafe, j_lm = 15715070 == (16777215 & canary), inBrowser = "undefined" != typeof navigator; inBrowser && j_lm && "Microsoft Internet Explorer" == navigator.appName ? (BigInteger.prototype.am = am2, dbits = 30) : inBrowser && j_lm && "Netscape" != navigator.appName ? (BigInteger.prototype.am = am1, dbits = 26) : (BigInteger.prototype.am = am3, dbits = 28), BigInteger.prototype.DB = dbits, BigInteger.prototype.DM = (1 << dbits) - 1, BigInteger.prototype.DV = 1 << dbits; var BI_FP = 52; BigInteger.prototype.FV = Math.pow(2, BI_FP), BigInteger.prototype.F1 = BI_FP - dbits, BigInteger.prototype.F2 = 2 * dbits - BI_FP; var rr, vv, BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz", BI_RC = new Array; for (rr = "0".charCodeAt(0), vv = 0; vv <= 9; ++vv)BI_RC[rr++] = vv; for (rr = "a".charCodeAt(0), vv = 10; vv < 36; ++vv)BI_RC[rr++] = vv; for (rr = "A".charCodeAt(0), vv = 10; vv < 36; ++vv)BI_RC[rr++] = vv; Classic.prototype.convert = cConvert, Classic.prototype.revert = cRevert, Classic.prototype.reduce = cReduce, Classic.prototype.mulTo = cMulTo, Classic.prototype.sqrTo = cSqrTo, Montgomery.prototype.convert = montConvert, Montgomery.prototype.revert = montRevert, Montgomery.prototype.reduce = montReduce, Montgomery.prototype.mulTo = montMulTo, Montgomery.prototype.sqrTo = montSqrTo, BigInteger.prototype.copyTo = bnpCopyTo, BigInteger.prototype.fromInt = bnpFromInt, BigInteger.prototype.fromString = bnpFromString, BigInteger.prototype.clamp = bnpClamp, BigInteger.prototype.dlShiftTo = bnpDLShiftTo, BigInteger.prototype.drShiftTo = bnpDRShiftTo, BigInteger.prototype.lShiftTo = bnpLShiftTo, BigInteger.prototype.rShiftTo = bnpRShiftTo, BigInteger.prototype.subTo = bnpSubTo, BigInteger.prototype.multiplyTo = bnpMultiplyTo, BigInteger.prototype.squareTo = bnpSquareTo, BigInteger.prototype.divRemTo = bnpDivRemTo, BigInteger.prototype.invDigit = bnpInvDigit, BigInteger.prototype.isEven = bnpIsEven, BigInteger.prototype.exp = bnpExp, BigInteger.prototype.toString = bnToString, BigInteger.prototype.negate = bnNegate, BigInteger.prototype.abs = bnAbs, BigInteger.prototype.compareTo = bnCompareTo, BigInteger.prototype.bitLength = bnBitLength, BigInteger.prototype.mod = bnMod, BigInteger.prototype.modPowInt = bnModPowInt, BigInteger.ZERO = nbv(0), BigInteger.ONE = nbv(1), NullExp.prototype.convert = nNop, NullExp.prototype.revert = nNop, NullExp.prototype.mulTo = nMulTo, NullExp.prototype.sqrTo = nSqrTo, Barrett.prototype.convert = barrettConvert, Barrett.prototype.revert = barrettRevert, Barrett.prototype.reduce = barrettReduce, Barrett.prototype.mulTo = barrettMulTo, Barrett.prototype.sqrTo = barrettSqrTo; var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997], lplim = (1 << 26) / lowprimes[lowprimes.length - 1]; BigInteger.prototype.chunkSize = bnpChunkSize, BigInteger.prototype.toRadix = bnpToRadix, BigInteger.prototype.fromRadix = bnpFromRadix, BigInteger.prototype.fromNumber = bnpFromNumber, BigInteger.prototype.bitwiseTo = bnpBitwiseTo, BigInteger.prototype.changeBit = bnpChangeBit, BigInteger.prototype.addTo = bnpAddTo, BigInteger.prototype.dMultiply = bnpDMultiply, BigInteger.prototype.dAddOffset = bnpDAddOffset, BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo, BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo, BigInteger.prototype.modInt = bnpModInt, BigInteger.prototype.millerRabin = bnpMillerRabin, BigInteger.prototype.clone = bnClone, BigInteger.prototype.intValue = bnIntValue, BigInteger.prototype.byteValue = bnByteValue, BigInteger.prototype.shortValue = bnShortValue, BigInteger.prototype.signum = bnSigNum, BigInteger.prototype.toByteArray = bnToByteArray, BigInteger.prototype.equals = bnEquals, BigInteger.prototype.min = bnMin, BigInteger.prototype.max = bnMax, BigInteger.prototype.and = bnAnd, BigInteger.prototype.or = bnOr, BigInteger.prototype.xor = bnXor, BigInteger.prototype.andNot = bnAndNot, BigInteger.prototype.not = bnNot, BigInteger.prototype.shiftLeft = bnShiftLeft, BigInteger.prototype.shiftRight = bnShiftRight, BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit, BigInteger.prototype.bitCount = bnBitCount, BigInteger.prototype.testBit = bnTestBit, BigInteger.prototype.setBit = bnSetBit, BigInteger.prototype.clearBit = bnClearBit, BigInteger.prototype.flipBit = bnFlipBit, BigInteger.prototype.add = bnAdd, BigInteger.prototype.subtract = bnSubtract, BigInteger.prototype.multiply = bnMultiply, BigInteger.prototype.divide = bnDivide, BigInteger.prototype.remainder = bnRemainder, BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder, BigInteger.prototype.modPow = bnModPow, BigInteger.prototype.modInverse = bnModInverse, BigInteger.prototype.pow = bnPow, BigInteger.prototype.gcd = bnGCD, BigInteger.prototype.isProbablePrime = bnIsProbablePrime, BigInteger.prototype.square = bnSquare, BigInteger.prototype.Barrett = Barrett; var rng_state, rng_pool, rng_pptr; if (null == rng_pool) { rng_pool = new Array, rng_pptr = 0; var t; if ("undefined" != typeof window && window.crypto) if (window.crypto.getRandomValues) { var ua = new Uint8Array(32); for (window.crypto.getRandomValues(ua), t = 0; t < 32; ++t)rng_pool[rng_pptr++] = ua[t] } else if ("Netscape" == navigator.appName && navigator.appVersion < "5") { var z = window.crypto.random(32); for (t = 0; t < z.length; ++t)rng_pool[rng_pptr++] = 255 & z.charCodeAt(t) } for (; rng_pptr < rng_psize;)t = Math.floor(65536 * Math.random()), rng_pool[rng_pptr++] = t >>> 8, rng_pool[rng_pptr++] = 255 & t; rng_pptr = 0, rng_seed_time() } SecureRandom.prototype.nextBytes = rng_get_bytes, Arcfour.prototype.init = ARC4init, Arcfour.prototype.next = ARC4next; var rng_psize = 256; BigInteger.SecureRandom = SecureRandom, BigInteger.BigInteger = BigInteger, exports = module.exports = BigInteger }).call(this) }, function (module, exports, __webpack_require__) {
  function padding(str) { var mod = str.length % 4, pad = 4 - mod; return 0 === mod ? str : str + new Array(1 + pad).join("=") } function byteArrayToString(array) { for (var result = "", i = 0; i < array.length; i++)result += String.fromCharCode(array[i]); return result } function stringToByteArray(str) { for (var arr = new Array(str.length), a = 0; a < str.length; a++)arr[a] = str.charCodeAt(a); return arr } function byteArrayToHex(raw) { for (var HEX = "", i = 0; i < raw.length; i++) { var _hex = raw[i].toString(16); HEX += 2 === _hex.length ? _hex : "0" + _hex } return HEX } function encodeString(str) { return base64.fromByteArray(stringToByteArray(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function (match, p1) { return String.fromCharCode("0x" + p1) }))).replace(/\+/g, "-").replace(/\//g, "_") } function decodeToString(str) { return str = padding(str).replace(/\-/g, "+").replace(/_/g, "/"), decodeURIComponent(byteArrayToString(base64.toByteArray(str)).split("").map(function (c) { return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2) }).join("")) } function decodeToHEX(str) { return byteArrayToHex(base64.toByteArray(padding(str))) } function base64ToBase64Url(base64String) { var SAFE_URL_ENCODING_MAPPING = { "+": "-", "/": "_", "=": "" }; return base64String.replace(/[+\/=]/g, function (m) { return SAFE_URL_ENCODING_MAPPING[m] }) } var base64 = __webpack_require__(19);
  module.exports = { encodeString: encodeString, decodeToString: decodeToString, byteArrayToString: byteArrayToString, stringToByteArray: stringToByteArray, padding: padding, byteArrayToHex: byteArrayToHex, decodeToHEX: decodeToHEX, base64ToBase64Url: base64ToBase64Url }
}, function (module, exports, __webpack_require__) { function process(jwks) { var modulus = base64.decodeToHEX(jwks.n), exp = base64.decodeToHEX(jwks.e); return { modulus: modulus, exp: exp } } function getJWKS(options, cb) { var url = options.jwksURI || urljoin(options.iss, ".well-known", "jwks.json"); return request.get(url).end(function (err, data) { var a, key, matchingKey = null; if (err) return cb(err); for (a = 0; a < data.body.keys.length && null === matchingKey; a++)key = data.body.keys[a], key.kid === options.kid && (matchingKey = key); return cb(null, process(matchingKey)) }) } var urljoin = __webpack_require__(9), base64 = __webpack_require__(44), request = __webpack_require__(11); module.exports = { process: process, getJWKS: getJWKS } }, function (module, exports) { function ConfigurationError(message) { this.name = "ConfigurationError", this.message = message || "" } function TokenValidationError(message) { this.name = "TokenValidationError", this.message = message || "" } ConfigurationError.prototype = Error.prototype, TokenValidationError.prototype = Error.prototype, module.exports = { ConfigurationError: ConfigurationError, TokenValidationError: TokenValidationError } }, function (module, exports) { function DummyCache() { } DummyCache.prototype.get = function () { return null }, DummyCache.prototype.has = function () { return !1 }, DummyCache.prototype.set = function () { }, module.exports = DummyCache }, function (module, exports, __webpack_require__) { function PluginHandler(webAuth, plugins) { this.plugins = plugins; for (var a = 0; a < this.plugins.length; a++) { if (this.plugins[a].version !== version.raw) { var pluginName = ""; throw this.plugins[a].constructor && this.plugins[a].constructor.name && (pluginName = this.plugins[a].constructor.name), new Error("Plugin " + pluginName + " version (" + this.plugins[a].version + ") is not compatible with the SDK version (" + version.raw + ")") } this.plugins[a].setWebAuth(webAuth) } } var version = __webpack_require__(20); PluginHandler.prototype.get = function (extensibilityPoint) { for (var a = 0; a < this.plugins.length; a++)if (this.plugins[a].supports(extensibilityPoint)) return this.plugins[a].init(); return null }, module.exports = PluginHandler }, function (module, exports) { (function (global) { function redirect(url) { global.window.location = url } function getDocument() { return global.window.document } function getWindow() { return global.window } module.exports = { redirect: redirect, getDocument: getDocument, getWindow: getWindow } }).call(exports, function () { return this }()) }, function (module, exports, __webpack_require__) { function TransactionManager(options) { options = options || {}, this.namespace = options.namespace || DEFAULT_NAMESPACE, this.keyLength = options.keyLength || 32 } var random = __webpack_require__(51), storage = __webpack_require__(52), DEFAULT_NAMESPACE = "com.auth0.auth."; TransactionManager.prototype.process = function (options) { var transaction; return options.responseType.indexOf("code") !== -1 ? options : options.responseType.indexOf("id_token") !== -1 && options.nonce ? options : (transaction = this.generateTransaction(options.appState, options.state, options.nonce), options.state = transaction.state, options.responseType.indexOf("id_token") !== -1 && (options.nonce = transaction.nonce), options) }, TransactionManager.prototype.generateTransaction = function (appState, state, nonce) { var transaction = state || random.randomString(this.keyLength); return nonce = nonce || random.randomString(this.keyLength), storage.setItem(this.namespace + transaction, { nonce: nonce, appState: appState }), { state: transaction, nonce: nonce } }, TransactionManager.prototype.getStoredTransaction = function (transaction) { var transactionData; return transactionData = storage.getItem(this.namespace + transaction), storage.removeItem(this.namespace + transaction), transactionData }, module.exports = TransactionManager }, function (module, exports, __webpack_require__) { function randomString(length) { var bytes = new Uint8Array(length), result = [], charset = "0123456789ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz-._~", cryptoObj = windowHelper.getWindow().crypto || windowHelper.getWindow().msCrypto; if (!cryptoObj) return null; for (var random = cryptoObj.getRandomValues(bytes), a = 0; a < random.length; a++)result.push(charset[random[a] % charset.length]); return result.join("") } var windowHelper = __webpack_require__(49); module.exports = { randomString: randomString } }, function (module, exports, __webpack_require__) { function getStorage(force) { return storage && !force || (storage = new StorageHandler), storage } var storage, StorageHandler = __webpack_require__(53); module.exports = { getItem: function (key) { var value = getStorage().getItem(key); return value ? JSON.parse(value) : value }, removeItem: function (key) { return getStorage().removeItem(key) }, setItem: function (key, value) { var json = JSON.stringify(value); return getStorage().setItem(key, json) }, reload: function () { getStorage(!0) } } }, function (module, exports, __webpack_require__) { function StorageHandler() { this.warn = new Warn({}), this.storage = windowHandler.getWindow().localStorage || new CookieStorage } var windowHandler = __webpack_require__(49), DummyStorage = __webpack_require__(54), CookieStorage = __webpack_require__(55), Warn = __webpack_require__(32); StorageHandler.prototype.failover = function () { return this.storage instanceof DummyStorage ? void this.warn.warning("DummyStorage: ignore failover") : void (this.storage instanceof CookieStorage ? (this.warn.warning("CookieStorage: failing over DummyStorage"), this.storage = new DummyStorage) : (this.warn.warning("LocalStorage: failing over CookieStorage"), this.storage = new CookieStorage)) }, StorageHandler.prototype.getItem = function (key) { try { return this.storage.getItem(key) } catch (e) { return this.warn.warning(e), this.failover(), this.getItem(key) } }, StorageHandler.prototype.removeItem = function (key) { try { return this.storage.removeItem(key) } catch (e) { return this.warn.warning(e), this.failover(), this.removeItem(key) } }, StorageHandler.prototype.setItem = function (key, value) { try { return this.storage.setItem(key, value) } catch (e) { return this.warn.warning(e), this.failover(), this.setItem(key, value) } }, module.exports = StorageHandler }, function (module, exports) { function DummyStorage() { } DummyStorage.prototype.getItem = function () { return null }, DummyStorage.prototype.removeItem = function () { }, DummyStorage.prototype.setItem = function () { }, module.exports = DummyStorage }, function (module, exports, __webpack_require__) { function CookieStorage() { } var cookies = __webpack_require__(56); CookieStorage.prototype.getItem = function (key) { return cookies.read(key) }, CookieStorage.prototype.removeItem = function (key) { cookies.erase(key) }, CookieStorage.prototype.setItem = function (key, value) { cookies.create(key, value, 1) }, module.exports = CookieStorage }, function (module, exports, __webpack_require__) { function create(name, value, days) { var date, expires; if (void 0 === windowHandler.getDocument().cookie || null === windowHandler.getDocument().cookie) throw new Error("cookie storage not available"); if (days) { var timeToExpire = 24 * days * 60 * 60 * 1e3; date = new Date, date.setTime(date.getTime() + timeToExpire), expires = "; expires=" + date.toGMTString() } else expires = ""; windowHandler.getDocument().cookie = name + "=" + base64Url.encode(value) + expires + "; path=/" } function read(name) { var i, cookie, cookies, nameEQ = name + "="; if (void 0 === windowHandler.getDocument().cookie || null === windowHandler.getDocument().cookie) throw new Error("cookie storage not available"); for (cookies = windowHandler.getDocument().cookie.split(";"), i = 0; i < cookies.length; i++) { for (cookie = cookies[i]; " " === cookie.charAt(0);)cookie = cookie.substring(1, cookie.length); if (0 === cookie.indexOf(nameEQ)) return base64Url.decode(cookie.substring(nameEQ.length, cookie.length)) } return null } function erase(name) { create(name, "", -1) } var windowHandler = __webpack_require__(49), base64Url = __webpack_require__(18); module.exports = { create: create, read: read, erase: erase } }, function (module, exports, __webpack_require__) { function Redirect(client, options) { this.baseOptions = options, this.client = client, this.warn = new Warn({ disableWarnings: !!options._disableDeprecationWarnings }) } var UsernamePassword = __webpack_require__(58), objectHelper = __webpack_require__(26), Warn = __webpack_require__(32), assert = __webpack_require__(27); Redirect.prototype.loginWithCredentials = function (options, cb) { var usernamePassword, params = objectHelper.merge(this.baseOptions, ["clientID", "redirectUri", "tenant", "responseType", "responseMode", "scope", "audience", "_csrf", "state", "_intstate", "nonce"])["with"](options); return assert.check(params, { type: "object", message: "options parameter is not valid" }, { responseType: { type: "string", message: "responseType option is required" } }), usernamePassword = new UsernamePassword(this.baseOptions), usernamePassword.login(params, function (err, data) { return err ? cb(err) : usernamePassword.callback(data) }) }, Redirect.prototype.signupAndLogin = function (options, cb) { var _this = this; return this.client.dbConnection.signup(options, function (err) { return err ? cb(err) : _this.loginWithCredentials(options, cb) }) }, module.exports = Redirect }, function (module, exports, __webpack_require__) { function UsernamePassword(options) { this.baseOptions = options, this.request = new RequestBuilder(options) } var urljoin = __webpack_require__(9), objectHelper = __webpack_require__(26), RequestBuilder = __webpack_require__(10), responseHandler = __webpack_require__(29), windowHelper = __webpack_require__(49); UsernamePassword.prototype.login = function (options, cb) { var url, body; return url = urljoin(this.baseOptions.rootUrl, "usernamepassword", "login"), options.username = options.username || options.email, options = objectHelper.blacklist(options, ["email"]), body = objectHelper.merge(this.baseOptions, ["clientID", "redirectUri", "tenant", "responseType", "responseMode", "scope", "audience"])["with"](options), body = objectHelper.toSnakeCase(body, ["auth0Client"]), this.request.post(url).send(body).end(responseHandler(cb)) }, UsernamePassword.prototype.callback = function (formHtml) { var div, form, _document = windowHelper.getDocument(); div = _document.createElement("div"), div.innerHTML = formHtml, form = _document.body.appendChild(div).children[0], form.submit() }, module.exports = UsernamePassword }, function (module, exports, __webpack_require__) { function Popup(webAuth, options) { this.baseOptions = options, this.client = webAuth.client, this.webAuth = webAuth, this.transactionManager = new TransactionManager(this.baseOptions.transaction), this.warn = new Warn({ disableWarnings: !!options._disableDeprecationWarnings }) } var urljoin = __webpack_require__(9), WinChan = __webpack_require__(60), urlHelper = __webpack_require__(61), assert = __webpack_require__(27), responseHandler = __webpack_require__(29), PopupHandler = __webpack_require__(62), objectHelper = __webpack_require__(26), Warn = __webpack_require__(32), TransactionManager = __webpack_require__(50); Popup.prototype.buildPopupHandler = function () { var pluginHandler = this.baseOptions.plugins.get("popup.getPopupHandler"); return pluginHandler ? pluginHandler.getPopupHandler() : new PopupHandler }, Popup.prototype.preload = function (options) { options = options || {}; var popup = this.buildPopupHandler(); return popup.preload(options), popup }, Popup.prototype.getPopupHandler = function (options, preload) { return options.popupHandler ? options.popupHandler : preload ? this.preload(options) : this.buildPopupHandler() }, Popup.prototype.callback = function (options) { var _this = this; WinChan.onOpen(function (popupOrigin, r, cb) { _this.webAuth.parseHash(options || {}, function (err, data) { return cb(err || data) }) }) }, Popup.prototype.authorize = function (options, cb) { var popup, url, relayUrl, popOpts = {}, pluginHandler = this.baseOptions.plugins.get("popup.authorize"), params = objectHelper.merge(this.baseOptions, ["clientID", "scope", "domain", "audience", "responseType", "redirectUri", "_csrf", "state", "_intstate", "nonce"])["with"](objectHelper.blacklist(options, ["popupHandler"])); return assert.check(params, { type: "object", message: "options parameter is not valid" }, { responseType: { type: "string", message: "responseType option is required" } }), relayUrl = urljoin(this.baseOptions.rootUrl, "relay.html"), options.owp ? params.owp = !0 : (popOpts.origin = urlHelper.extractOrigin(params.redirectUri), relayUrl = params.redirectUri), options.popupOptions && (popOpts.popupOptions = objectHelper.pick(options.popupOptions, ["width", "height"])), pluginHandler && (params = pluginHandler.processParams(params)), params = this.transactionManager.process(params), delete params.domain, url = this.client.buildAuthorizeUrl(params), popup = this.getPopupHandler(options), popup.load(url, relayUrl, popOpts, responseHandler(cb)) }, Popup.prototype.loginWithCredentials = function (options, cb) { var params, popup, url, relayUrl; return assert.check(options, { type: "object", message: "options parameter is not valid" }, { clientID: { optional: !0, type: "string", message: "clientID option is required" }, redirectUri: { optional: !0, type: "string", message: "redirectUri option is required" }, responseType: { optional: !0, type: "string", message: "responseType option is required" }, scope: { optional: !0, type: "string", message: "scope option is required" }, audience: { optional: !0, type: "string", message: "audience option is required" } }), popup = this.getPopupHandler(options), options = objectHelper.merge(this.baseOptions, ["clientID", "scope", "domain", "audience", "_csrf", "state", "_intstate", "nonce"])["with"](objectHelper.blacklist(options, ["popupHandler"])), params = objectHelper.pick(options, ["clientID", "domain"]), params.options = objectHelper.toSnakeCase(objectHelper.pick(options, ["password", "connection", "state", "scope", "_csrf", "device"])), params.options.username = options.username || options.email, url = urljoin(this.baseOptions.rootUrl, "sso_dbconnection_popup", options.clientID), relayUrl = urljoin(this.baseOptions.rootUrl, "relay.html"), popup.load(url, relayUrl, { params: params }, responseHandler(cb)) }, Popup.prototype.passwordlessVerify = function (options, cb) { var _this = this; return this.client.passwordless.verify(objectHelper.blacklist(options, ["popupHandler"]), function (err) { return err ? cb(err) : (options.username = options.phoneNumber || options.email, options.password = options.verificationCode, delete options.email, delete options.phoneNumber, delete options.verificationCode, delete options.type, void _this.client.loginWithResourceOwner(options, cb)) }) }, Popup.prototype.signupAndLogin = function (options, cb) { var _this = this, popupHandler = this.getPopupHandler(options, !0); return options.popupHandler = popupHandler, this.client.dbConnection.signup(objectHelper.blacklist(options, ["popupHandler"]), function (err) { return err ? (popupHandler._current_popup && popupHandler._current_popup.kill(), cb(err)) : void _this.loginWithCredentials(options, cb) }) }, module.exports = Popup }, function (module, exports) { var WinChan = function () { function addListener(w, event, cb) { w.attachEvent ? w.attachEvent("on" + event, cb) : w.addEventListener && w.addEventListener(event, cb, !1) } function removeListener(w, event, cb) { w.detachEvent ? w.detachEvent("on" + event, cb) : w.removeEventListener && w.removeEventListener(event, cb, !1) } function isInternetExplorer() { if ("undefined" == typeof navigator) return !1; var rv = -1, ua = navigator.userAgent; if ("Microsoft Internet Explorer" === navigator.appName) { var re = new RegExp("MSIE ([0-9]{1,}[.0-9]{0,})"); null != re.exec(ua) && (rv = parseFloat(RegExp.$1)) } else if (ua.indexOf("Trident") > -1) { var re = new RegExp("rv:([0-9]{2,2}[.0-9]{0,})"); null !== re.exec(ua) && (rv = parseFloat(RegExp.$1)) } return rv >= 8 } function isFennec() { try { var userAgent = navigator.userAgent; return userAgent.indexOf("Fennec/") != -1 || userAgent.indexOf("Firefox/") != -1 && userAgent.indexOf("Android") != -1 } catch (e) { } return !1 } function isSupported() { return "undefined" != typeof window && window.JSON && window.JSON.stringify && window.JSON.parse && window.postMessage } function extractOrigin(url) { /^https?:\/\//.test(url) || (url = window.location.href); var m = /^(https?:\/\/[\-_a-zA-Z\.0-9:]+)/.exec(url); return m ? m[1] : url } function findRelay() { for (var frames = (window.location, window.opener.frames), i = frames.length - 1; i >= 0; i--)try { if (frames[i].location.protocol === window.location.protocol && frames[i].location.host === window.location.host && frames[i].name === RELAY_FRAME_NAME) return frames[i] } catch (e) { } } var RELAY_FRAME_NAME = "__winchan_relay_frame", CLOSE_CMD = "die", isIE = isInternetExplorer(); return isSupported() ? { open: function (opts, cb) { function cleanup() { if (iframe && document.body.removeChild(iframe), iframe = void 0, closeInterval && (closeInterval = clearInterval(closeInterval)), removeListener(window, "message", onMessage), removeListener(window, "unload", cleanup), w) try { w.close() } catch (securityViolation) { messageTarget.postMessage(CLOSE_CMD, origin) } w = messageTarget = void 0 } function onMessage(e) { if (e.origin === origin) { try { var d = JSON.parse(e.data) } catch (err) { if (!cb) throw err; cb(err) } "ready" === d.a ? messageTarget.postMessage(req, origin) : "error" === d.a ? (cleanup(), cb && (cb(d.d), cb = null)) : "response" === d.a && (cleanup(), cb && (cb(null, d.d), cb = null)) } } if (!cb) throw "missing required callback argument"; var err; opts.url || (err = "missing required 'url' parameter"), opts.relay_url || (err = "missing required 'relay_url' parameter"), err && setTimeout(function () { cb(err) }, 0), opts.window_name || (opts.window_name = null), opts.window_features && !isFennec() || (opts.window_features = void 0); var iframe, origin = opts.origin || extractOrigin(opts.url); if (origin !== extractOrigin(opts.relay_url)) return setTimeout(function () { cb("invalid arguments: origin of url and relay_url must match") }, 0); var messageTarget; isIE && (iframe = document.createElement("iframe"), iframe.setAttribute("src", opts.relay_url), iframe.style.display = "none", iframe.setAttribute("name", RELAY_FRAME_NAME), document.body.appendChild(iframe), messageTarget = iframe.contentWindow); var w = opts.popup || window.open(opts.url, opts.window_name, opts.window_features); opts.popup && (w.location.href = opts.url), messageTarget || (messageTarget = w); var closeInterval = setInterval(function () { w && w.closed && (cleanup(), cb && (cb("User closed the popup window"), cb = null)) }, 500), req = JSON.stringify({ a: "request", d: opts.params }); return addListener(window, "unload", cleanup), addListener(window, "message", onMessage), { close: cleanup, focus: function () { if (w) try { w.focus() } catch (e) { } } } }, onOpen: function (cb) { function doPost(msg) { msg = JSON.stringify(msg), isIE ? msgTarget.doPost(msg, o) : msgTarget.postMessage(msg, o) } function onMessage(e) { var d; try { d = JSON.parse(e.data) } catch (err) { } d && "request" === d.a && (removeListener(window, "message", onMessage), o = e.origin, cb && setTimeout(function () { cb(o, d.d, function (r) { cb = void 0, doPost({ a: "response", d: r }) }) }, 0)) } function onDie(e) { if (e.data === CLOSE_CMD) try { window.close() } catch (o_O) { } } var o = "*", msgTarget = isIE ? findRelay() : window.opener; if (!msgTarget) throw "can't find relay frame"; addListener(isIE ? msgTarget : window, "message", onMessage), addListener(isIE ? msgTarget : window, "message", onDie); try { doPost({ a: "ready" }) } catch (e) { addListener(msgTarget, "load", function (e) { doPost({ a: "ready" }) }) } var onUnload = function () { try { removeListener(isIE ? msgTarget : window, "message", onDie) } catch (ohWell) { } cb && doPost({ a: "error", d: "client closed window" }), cb = void 0; try { window.close() } catch (e) { } }; return addListener(window, "unload", onUnload), { detach: function () { removeListener(window, "unload", onUnload) } } } } : { open: function (url, winopts, arg, cb) { setTimeout(function () { cb("unsupported browser") }, 0) }, onOpen: function (cb) { setTimeout(function () { cb("unsupported browser") }, 0) } } }(); "undefined" != typeof module && module.exports && (module.exports = WinChan) }, function (module, exports) { function extractOrigin(url) { /^https?:\/\//.test(url) || (url = window.location.href); var m = /^(https?:\/\/[-_a-zA-Z.0-9:]+)/.exec(url); return m ? m[1] : url } module.exports = { extractOrigin: extractOrigin } }, function (module, exports, __webpack_require__) { function PopupHandler() { this._current_popup = null } var WinChan = __webpack_require__(60), windowHandler = __webpack_require__(49), objectHelper = __webpack_require__(26), qs = __webpack_require__(21); PopupHandler.prototype.calculatePosition = function (options) { var width = options.width || 500, height = options.height || 600, _window = windowHandler.getWindow(), screenX = "undefined" != typeof _window.screenX ? _window.screenX : _window.screenLeft, screenY = "undefined" != typeof _window.screenY ? _window.screenY : _window.screenTop, outerWidth = "undefined" != typeof _window.outerWidth ? _window.outerWidth : _window.document.body.clientWidth, outerHeight = "undefined" != typeof _window.outerHeight ? _window.outerHeight : _window.document.body.clientHeight, left = (outerWidth - width) / 2, top = (outerHeight - height) / 2; return { width: width, height: height, left: screenX + left, top: screenY + top } }, PopupHandler.prototype.preload = function (options) { var _this = this, _window = windowHandler.getWindow(), popupPosition = this.calculatePosition(options.popupOptions || {}), popupOptions = objectHelper.merge(popupPosition)["with"](options.popupOptions), url = options.url || "about:blank", windowFeatures = qs.stringify(popupOptions, { encode: !1, delimiter: "," }); return this._current_popup && !this._current_popup.closed ? this._current_popup : (this._current_popup = _window.open(url, "auth0_signup_popup", windowFeatures), this._current_popup.kill = function () { this.close(), _this._current_popup = null }, this._current_popup) }, PopupHandler.prototype.load = function (url, relayUrl, options, cb) { var _this = this, popupPosition = this.calculatePosition(options.popupOptions || {}), popupOptions = objectHelper.merge(popupPosition)["with"](options.popupOptions), winchanOptions = objectHelper.merge({ url: url, relay_url: relayUrl, window_features: qs.stringify(popupOptions, { delimiter: ",", encode: !1 }), popup: this._current_popup })["with"](options), popup = WinChan.open(winchanOptions, function (err, data) { return _this._current_popup = null, cb(err, data) }); return popup.focus(), popup }, module.exports = PopupHandler }, function (module, exports, __webpack_require__) { function SilentAuthenticationHandler(options) { this.authenticationUrl = options.authenticationUrl, this.timeout = options.timeout || 6e4, this.handler = null, this.postMessageDataType = options.postMessageDataType || !1 } var IframeHandler = __webpack_require__(64); SilentAuthenticationHandler.create = function (options) { return new SilentAuthenticationHandler(options) }, SilentAuthenticationHandler.prototype.login = function (usePostMessage, callback) { this.handler = new IframeHandler({ auth0: this.auth0, url: this.authenticationUrl, eventListenerType: usePostMessage ? "message" : "load", callback: this.getCallbackHandler(callback, usePostMessage), timeout: this.timeout, eventValidator: this.getEventValidator(), timeoutCallback: function () { callback(null, "#error=timeout&error_description=Timeout+during+authentication+renew.") }, usePostMessage: usePostMessage || !1 }), this.handler.init() }, SilentAuthenticationHandler.prototype.getEventValidator = function () { var _this = this; return { isValid: function (eventData) { switch (eventData.event.type) { case "message": return _this.postMessageDataType === !1 || eventData.event.data.type && eventData.event.data.type === _this.postMessageDataType; case "load": default: return !0 } } } }, SilentAuthenticationHandler.prototype.getCallbackHandler = function (callback, usePostMessage) { return function (eventData) { var callbackValue; callbackValue = usePostMessage ? "object" == typeof eventData.event.data && eventData.event.data.hash ? eventData.event.data.hash : eventData.event.data : eventData.sourceObject.contentWindow.location.hash, callback(null, callbackValue) } }, module.exports = SilentAuthenticationHandler }, function (module, exports, __webpack_require__) { function IframeHandler(options) { if (this.url = options.url, this.callback = options.callback, this.timeout = options.timeout || 6e4, this.timeoutCallback = options.timeoutCallback || null, this.eventListenerType = options.eventListenerType || "message", this.iframe = null, this.timeoutHandle = null, this._destroyTimeout = null, this.transientMessageEventListener = null, this.proxyEventListener = null, this.eventValidator = options.eventValidator || { isValid: function () { return !0 } }, "function" != typeof this.callback) throw new Error("options.callback must be a function") } var windowHelper = __webpack_require__(49); IframeHandler.prototype.init = function () { var _this = this, _window = windowHelper.getWindow(); switch (this.iframe = _window.document.createElement("iframe"), this.iframe.style.display = "none", this.iframe.src = this.url, this.proxyEventListener = function (e) { _this.eventListener(e) }, this.eventListenerType) { case "message": this.eventSourceObject = _window; break; case "load": this.eventSourceObject = this.iframe; break; default: throw new Error("Unsupported event listener type: " + this.eventListenerType) }this.eventSourceObject.addEventListener(this.eventListenerType, this.proxyEventListener, !1), _window.document.body.appendChild(this.iframe), this.timeoutHandle = setTimeout(function () { _this.timeoutHandler() }, this.timeout) }, IframeHandler.prototype.eventListener = function (event) { var eventData = { event: event, sourceObject: this.eventSourceObject }; this.eventValidator.isValid(eventData) && (this.destroy(), this.callback(eventData)) }, IframeHandler.prototype.timeoutHandler = function () { this.destroy(), this.timeoutCallback && this.timeoutCallback() }, IframeHandler.prototype.destroy = function () { var _this = this, _window = windowHelper.getWindow(); clearTimeout(this.timeoutHandle), this._destroyTimeout = setTimeout(function () { _this.eventSourceObject.removeEventListener(_this.eventListenerType, _this.proxyEventListener, !1), _window.document.body.removeChild(_this.iframe) }, 0) }, module.exports = IframeHandler }, function (module, exports, __webpack_require__) { function CrossOriginAuthentication(webAuth, options) { this.webAuth = webAuth, this.baseOptions = options, this.request = new RequestBuilder(options) } function getFragment(name) { var theWindow = windowHelper.getWindow(), value = "&" + theWindow.location.hash.substring(1), parts = value.split("&" + name + "="); if (2 === parts.length) return parts.pop().split("&").shift() } function createKey(origin, coId) { return ["co/verifier", encodeURIComponent(origin), encodeURIComponent(coId)].join("/") } function tryGetVerifier(theWindow, key) { try { var verifier = theWindow.sessionStorage[key]; return theWindow.sessionStorage.removeItem(key), verifier } catch (e) { return "" } } var urljoin = __webpack_require__(9), windowHelper = __webpack_require__(49), objectHelper = __webpack_require__(26), RequestBuilder = __webpack_require__(10); CrossOriginAuthentication.prototype.login = function (options, cb) { var _this = this, theWindow = windowHelper.getWindow(), url = urljoin(this.baseOptions.rootUrl, "/co/authenticate"), authenticateBody = { client_id: options.clientID || this.baseOptions.clientID, username: options.username || options.email }; options.password && (authenticateBody.password = options.password), options.otp && (authenticateBody.otp = options.otp); var realm = options.realm || this.baseOptions.realm; if (realm) { var credentialType = options.credentialType || this.baseOptions.credentialType || "http://auth0.com/oauth/grant-type/password-realm"; authenticateBody.realm = realm, authenticateBody.credential_type = credentialType } else authenticateBody.credential_type = "password"; this.request.post(url).withCredentials().send(authenticateBody).end(function (err, data) { if (err) { var errorObject = err.response && err.response.body || { error: "request_error", error_description: JSON.stringify(err) }; return cb(errorObject) } options = objectHelper.blacklist(options, ["username", "password", "credentialType", "otp"]); var authorizeOptions = objectHelper.merge(options)["with"]({ loginTicket: data.body.login_ticket }), key = createKey(_this.baseOptions.rootUrl, data.body.co_id); theWindow.sessionStorage[key] = data.body.co_verifier, _this.webAuth.authorize(authorizeOptions) }) }, CrossOriginAuthentication.prototype.callback = function () { var targetOrigin = decodeURIComponent(getFragment("origin")), theWindow = windowHelper.getWindow(); theWindow.addEventListener("message", function (evt) { if ("co_verifier_request" === evt.data.type) { var key = createKey(evt.origin, evt.data.request.id), verifier = tryGetVerifier(theWindow, key); evt.source.postMessage({ type: "co_verifier_response", response: { verifier: verifier } }, evt.origin) } }), theWindow.parent.postMessage({ type: "ready" }, targetOrigin) }, module.exports = CrossOriginAuthentication }, function (module, exports, __webpack_require__) { var applyDefault = __webpack_require__(67), errorHelper = __webpack_require__(68); module.exports = function (auth0, window) { function PingAuthClient(config) { function handleResponse(err, result) { return err ? "login_required" === err.error ? errorHelper.invalidAuthentication("Invalid authentication", err) : "timeout" === err.error ? errorHelper.systemError("Timeout - check browser console for errors", err) : errorHelper.systemError("Internal server error", err) : result ? result.accessToken ? { retrievalTime: new Date, accessToken: result.accessToken } : errorHelper.systemError("Failed to get accessToken from " + JSON.stringify(result)) : {} } function warnOnSpecifyingIdp(conn) { conn && "default" !== conn && console.warn("Non default IDP specified: " + conn + "(reserved for internal testing)") } function removeHash(url) { return url.split("#")[0] } function encodeScopes(scopes) { if (scopes) { if (Array.isArray(scopes)) return scopes.join(" "); throw errorHelper.invalidArgument("Invalid scope, must be array: " + scopes) } return "" } var domains = { predev: "predev.auth.coxautoinc.com", dev: "sandbox.auth.coxautoinc.com", qa: "uat.auth.coxautoinc.com", prod: "auth.coxautoinc.com" }; if (config.environment || (config.environment = "prod"), warnOnSpecifyingIdp(config.connection), config = applyDefault(config, { domain: domains[config.environment] }), !config.clientID) throw errorHelper.invalidArgument("No client id"); if (["predev", "dev", "qa", "prod"].indexOf(config.environment) < 0) throw errorHelper.invalidArgument("Invalid runtime environment: " + config.environment); var auth0Client = new auth0.WebAuth({ clientID: config.clientID, domain: config.domain, redirectUri: config.redirectUri }); this.renewAuth = function (options) { return new Promise(function (resolve, reject) { try { options = applyDefault(options, { timeout: 5e3, connection: config.connection, scopes: config.scopes }), warnOnSpecifyingIdp(options.connection), auth0Client.renewAuth({ redirectUri: "https://static.auth.coxautoinc.com/auth-client-js/latest/silent-callback.html", usePostMessage: !0, connection: options.connection, postMessageDataType: "coxautoinc.auth.AuthClient", postMessageOrigin: "https://static.auth.coxautoinc.com", timeout: options.timeout, scope: encodeScopes(options.scopes) }, function (err, result) { var response = handleResponse(err, result); response instanceof Error ? reject(response) : resolve(response) }) } catch (e) { reject(errorHelper.systemError("Failed in renewAuth", e)) } }) }, this.authorize = function (options) { return new Promise(function (resolve, reject) { try { options = applyDefault(options, { redirectUri: config.redirectUri, connection: config.connection, scopes: config.scopes }), options.redirectUri || reject(errorHelper.invalidArgument("No redirectUri")), warnOnSpecifyingIdp(options.connection), auth0Client.authorize({ redirectUri: options.redirectUri, responseType: "token", connection: options.connection, scope: encodeScopes(options.scopes) }), resolve("Redirecting to authorize with callback " + options.redirectUri) } catch (e) { reject(errorHelper.systemError("Failed in authorize", e)) } }) }, this.parseHash = function () { return new Promise(function (resolve, reject) { try { auth0Client.parseHash({}, function (err, result) { var response = handleResponse(err, result); response instanceof Error ? reject(response) : resolve(response) }) } catch (e) { reject(errorHelper.systemError("Failed in parseHash", e)) } }) }, this.logout = function (options) { return new Promise(function (resolve, reject) { try { options = applyDefault(options, { returnTo: null }); var subDomain = { predev: "login-qa", dev: "login.dev", qa: "login-qa", prod: "login" }[config.environment], logoutUrl = "https://" + subDomain + ".dealertrack.com/logout/"; if (!options.returnTo) return window.top.location.href = logoutUrl, void resolve("Logged out and redirected to login"); var frame = window.document.createElement("iframe"); frame.sandbox = "allow-scripts allow-same-origin allow-forms", frame.style.display = "none", frame.src = logoutUrl, window.document.body.appendChild(frame), setTimeout(function () { try { var forceReload = removeHash(window.top.location.href) === removeHash(options.returnTo); window.top.location.href = options.returnTo, forceReload && window.top.location.reload(), resolve("Logged out and redirected to " + options.returnTo) } catch (e) { reject(errorHelper.systemError("Failed to redirect after logout", e)) } }, 1500) } catch (e) { reject(errorHelper.systemError("Failed in logout", e)) } }) } } var Class = PingAuthClient; return Class.errorNames = errorHelper.errorNames, Class } }, function (module, exports) {
module.exports = function (target, defaults) {
  target || (target = {}); for (var k in defaults) defaults.hasOwnProperty(k) && !target.hasOwnProperty(k) && (target[k] = defaults[k]);
  return target
}
}, function (module, exports) { function systemError(message, meta) { return buildError(errorNames.SYSTEM_ERROR, message, meta) } function invalidAuthentication(message, meta) { return buildError(errorNames.INVALID_AUTHENTICATION, message, meta) } function applicationError(message, meta) { return buildError(errorNames.APPLICATION_ERROR, message, meta) } function invalidArgument(message, meta) { return buildError(errorNames.INVALID_ARGUMENT, message, meta) } function buildError(name, message, meta) { var err = new Error(message || ""); return err.name = name, err.meta = {}, meta && ("object" == typeof meta ? Object.getOwnPropertyNames(meta).forEach(function (k) { err.meta[k] = meta[k] }) : err.meta.rawString = String(meta)), err } var errorNames = { SYSTEM_ERROR: "SystemError", INVALID_AUTHENTICATION: "InvalidAuthentication", APPLICATION_ERROR: "ApplicationError", INVALID_ARGUMENT: "InvalidArgument" }; module.exports = { systemError: systemError, invalidAuthentication: invalidAuthentication, applicationError: applicationError, invalidArgument: invalidArgument, errorNames: errorNames } }]);
//# sourceMappingURL=auth-client.js.map